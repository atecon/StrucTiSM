function void prepare_system_matrices (bundle *self)
    /* Call functions preparing various system matrices. */

    if self.special_case_id
        matrices self.SysMat = array(0)
    else
        initialize_system_matrices(&self)
    endif
end function


# TODO: needs testing with different components + frequencies. E.g.
# C1: freq=7, dummy, C2: freq=365, trigonometric
function matrix Qseasonals (const bundle self)
    /* Call actual function. */

    matrix ret
    strings components = getkeys(self.seasonal)

    loop foreach i components
        scalar k = self.seasonal["$i"].frequency - 1

        if self.seasonal["$i"].type == "trigonometric" && \
            self.seasonal["$i"].stochastic == TRUE
            matrix seas = diagcat(ret, mshape({1,0}, k, 1))

        elif self.seasonal["$i"].type == "trigonometric" && \
            self.seasonal["$i"].stochastic == FALSE
            # TODO: Can we implement this?
            errorif(TRUE, "Non-stochastic trigonometric seasonality not supported.")

        elif self.seasonal["$i"].type == "dummy" && \
            self.seasonal["$i"].stochastic == TRUE
            matrix seas = diagcat(ret, 1 | zeros(k-1, 1))

        elif self.seasonal["$i"].type == "dummy" && \
            self.seasonal["$i"].stochastic == FALSE
            matrix seas = diagcat(ret, zeros(k, 1))
        endif

        if nelem(components) == 1
            ret = seas
            break
        endif
        ret = (i > 1) ? diagcat(ret, seas) : seas
    endloop

    return ret
end function



function matrix Qmat (const bundle self)
    /* This function returns a matrix mapping the stochastic shocks into the
     state transition variance matrix: it has as many rows as the dimension
     of the state vector and as many columns as the number of variances
     to estimate. */

    matrix ret

    if self.type_trend == "stochastic"
        ret = diagcat(ret, 1)
    elif self.type_trend == "deterministic"
        ret = diagcat(ret, 0)
    endif

    if self.type_slope == "stochastic"
        ret = diagcat(ret, 1)
    elif self.type_slope == "deterministic"
        ret = diagcat(ret, 0)
    else
        # nothing to do if no slope is requested
    endif

    ret = diagcat(ret, Qseasonals(self))

    return selifc(ret, maxc(ret) .> 0)
end function


# 1.1 BSM transition matrix with particular cases:
# no slope/slope, no seasonal/seasonal trigon./seasonal dummies

function matrix trigonometric_seasonality (const scalar pd)
    /* Compute BSM transition matrix for trigonometric seasonality.
    return: type, description */

    odd = pd % 2
    dim = pd - 1
    H = floor(pd/2) - 1 + odd
    ret = zeros(dim, dim)
    fin = 0

    loop i = 1..H
        ini = fin+1
        fin = ini+1
        scalar c = cos(2*$pi * i/pd)
        scalar s = sin(2*$pi * i/pd)
        ret[ini:fin, ini:fin] = {c, s; -s, c}
    endloop
    if !odd
        ret[H*2 + 1, H*2 + 1] = -1
    endif

    return variable
end function

function matrix dummy_seasonality (const scalar pd)
    /* Compute BSM transition matrix for seasonal dummies.
    return: type, description */

    return -ones(1, pd-1) | (I(pd-2) ~ 0)
end function


# TODO: needs testing with different components + frequencies. E.g.
# C1: freq=7, dummy, C2: freq=365, trigonometric
function matrix Tseasonals (const bundle self)
    /* Call actual function. */

    matrix ret
    strings components = getkeys(self.seasonal)

    loop foreach i components
        if self.seasonal["$i"].type == "dummy"
            matrix seas = dummy_seasonality(self.seasonal["$i"].frequency)
        elif
            self.seasonal["$i"].type == "trigonometric"
            matrix seas =  \
                trigonometric_seasonality(self.seasonal["$i"].frequency)
        endif

        if nelem(components) == 1
            ret = seas
            break
        endif
        ret = (i > 1) ? diagcat(ret, seas) : seas
    endloop

    return ret
end function


function matrix Tmat (const bundle self)
    /* Compile the transition matrix T. */

    if self.type_slope != "none"
        ret = {1, 1; 0, 1}  # random-walk in beta
    else
        ret = {1}
    endif

    if self.n_seasonal_components
        matrix seas = Tseasonals(self)
        ret = diagcat(ret, seas)
    endif

    return ret
end function


function void initialize_system_matrices (bundle *self)
    /* Construct all necessary system matrices and add to self. */
    # int trend, int slope, int seasonal, scalar *nStates, scalar *nVar)

    #matrices ret = array(3)
    # in this order: T (statemat), Q (used for statevar)
    # Z (obsmat)

    # Transition equation
    matrix self.Tmat = Tmat(self)
    scalar self.nStates = rows(self.Tmat)   # size of state vector
    
    # Square matrix of variance
    matrix self.Qmat = Qmat(self)
    self.nVar = cols(self.Qmat)

    # measurement equation: matrix of the state vector
    matrix self.Zmat = Zmat(self)

    if rows(self.Qmat) != self.nStates
        print self
        # sanity check
        printf "Mismatch! (nStates = %d)\n", self.nStates
        printf "statemat (T):\n%5.1f\n", self.Tmat
        printf "Q:\n%5.1f\n", self.Qmat
        printf "obsmat (Z):\n%5.1f\n", self.Zmat
    endif
end function


# TODO: needs testing with different components + frequencies. E.g.
# C1: freq=7, dummy, C2: freq=365, trigonometric
function matrix Zseasonals (const bundle self)
    /* Call actual function. */

    matrix ret
    strings components = getkeys(self.seasonal)

    loop foreach i components
        scalar pd = self.seasonal["$i"].frequency

        if self.seasonal["$i"].type == "dummy"
            k = pd - 2
            matrix seas = 1 | zeros(k, 1)
        else
            k = pd - 1
            matrix seas = mshape({1,0}, $pd - 1, 1)
        endif

        if nelem(components) == 1
            ret = seas
            break
        endif
        ret = (i > 1) ? diagcat(ret, seas) : seas
    endloop

    return ret
end function

function matrix Zmat (const bundle self)
    /* Construct measurement equation matrix. */

    matrix Z

    # trend component
    if self.type_slope == "none"
        Z = {1}
    else
        Z = { 1; 0 }
    endif

    Z |= Zseasonals(self)

   return Z
end function
