function void prepare_system_matrices (bundle *self)
    /* Call functions preparing various system matrices. */

    if self.special_case_id
        matrices self.SysMat = array(0)
    else
        initialize_system_matrices(&self)
    endif
end function


# TODO: needs testing with different components + frequencies. E.g.
# C1: freq=7, dummy, C2: freq=365, trigonometric
function matrix Qseasonals (const bundle self)
    /* Call actual function. */

    matrix ret
    strings components = getkeys(self.seasonal)

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        scalar k = self.seasonal["@key"].frequency - 1

        if self.seasonal["@key"].type == "trigonometric" && \
            self.seasonal["@key"].stochastic == TRUE
            matrix seas = diagcat(ret, mshape({1,0}, k, 1))

        elif self.seasonal["@key"].type == "trigonometric" && \
            self.seasonal["@key"].stochastic == FALSE
            # TODO: Can we implement this?
            errorif(TRUE, "Non-stochastic trigonometric seasonality not supported.")

        elif self.seasonal["@key"].type == "dummy" && \
            self.seasonal["@key"].stochastic == TRUE
            matrix seas = diagcat(ret, 1 | zeros(k-1, 1))

        elif self.seasonal["@key"].type == "dummy" && \
            self.seasonal["@key"].stochastic == FALSE
            matrix seas = diagcat(ret, zeros(k, 1))
        endif

        if nelem(components) == 1
            ret = seas
            break
        endif
        ret = (i > 1) ? diagcat(ret, seas) : seas
    endloop

    return ret
end function


function matrix Qmat (const bundle self)
    /* This function returns a matrix mapping the stochastic shocks into the
     state transition variance matrix: it has as many rows as the dimension
     of the state vector and as many columns as the number of variances
     to estimate. */

    matrix ret

    if self.type_trend == "stochastic"
        ret = diagcat(ret, 1)
    elif self.type_trend == "deterministic"
        ret = diagcat(ret, 0)
    endif

    if self.type_slope == "stochastic"
        ret = diagcat(ret, 1)
    elif self.type_slope == "deterministic"
        ret = diagcat(ret, 0)
    else
        # nothing to do if no slope is requested
    endif

    ret = diagcat(ret, Qseasonals(self))
    ret = selifc(ret, maxc(ret) .> 0)

    return ret
end function


# 1.1 BSM transition matrix with particular cases:
# no slope/slope, no seasonal/seasonal trigon./seasonal dummies

function matrix trigonometric_seasonality (const scalar pd)
    /* Compute BSM transition matrix for trigonometric seasonality.
    return: type, description */

    odd = pd % 2
    dim = pd - 1
    H = floor(pd/2) - 1 + odd
    ret = zeros(dim, dim)
    fin = 0

    loop i = 1..H
        ini = fin+1
        fin = ini+1
        scalar c = cos(2*$pi * i/pd)
        scalar s = sin(2*$pi * i/pd)
        ret[ini:fin, ini:fin] = {c, s; -s, c}
    endloop
    if !odd
        ret[H*2 + 1, H*2 + 1] = -1
    endif

    return ret
end function

function matrix dummy_seasonality (const scalar pd)
    /* Compute BSM transition matrix for seasonal dummies.
    return: type, description */

    return -ones(1, pd-1) | (I(pd-2) ~ 0)
end function


function matrix Tseasonals (const bundle self)
    /* Call actual function to construct seasonals for T matrix. */

    matrix ret
    strings components = getkeys(self.seasonal)

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        if self.seasonal["@key"].type == "dummy"
            matrix seas = dummy_seasonality(self.seasonal["@key"].frequency)
        elif self.seasonal["@key"].type == "trigonometric"
            matrix seas =  \
                trigonometric_seasonality(self.seasonal["@key"].frequency)
        endif

        if nelem(components) == 1
            ret = seas
            break
        endif
        ret = (i > 1) ? diagcat(ret, seas) : seas
    endloop

    return ret
end function


function matrix Tmat (const bundle self)
    /* Compile the transition matrix T. */

    if self.type_slope != "none"
        ret = {1, 1; 0, 1}  # random-walk in beta
    else
        ret = {1}
    endif

    if self.n_seasonal_components
        matrix seas = Tseasonals(self)
        ret = diagcat(ret, seas)
    endif

    return ret
end function


function void initialize_system_matrices (bundle *self)
    /* Construct all necessary system matrices and add to self. */
    # int trend, int slope, int seasonal, scalar *nStates, scalar *nVar)

    # Transition equation
    matrix self.Tmat = Tmat(self)
    scalar self.nStates = rows(self.Tmat)   # size of state vector
    
    # Square matrix of variance
    matrix self.Qmat = Qmat(self)
    self.nVar = cols(self.Qmat)

    # measurement equation: matrix of the state vector
    matrix self.Zmat = Zmat(self)

    if rows(self.Qmat) != self.nStates
        print_sanity_check_results(self)
    endif
end function


function void print_sanity_check_results (const bundle self)
    /* Print details for debugging. */

    printf "Mismatch! (nStates = %d)\n", self.nStates
    printf "statemat (T):\n%5.1f\n", self.Tmat
    printf "Q:\n%5.1f\n", self.Qmat
    printf "obsmat (Z):\n%5.1f\n", self.Zmat
end function


# TODO: needs testing with different components + frequencies. E.g.
# C1: freq=7, dummy, C2: freq=365, trigonometric
function matrix Zseasonals (const bundle self)
    /* Call actual function. */

    matrix ret
    strings components = getkeys(self.seasonal)

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        scalar pd = self.seasonal["@key"].frequency

        if self.seasonal["@key"].type == "dummy"
            k = pd - 2
            matrix seas = 1 | zeros(k, 1)
        else
            k = pd - 1
            matrix seas = mshape({1,0}, $pd - 1, 1)
        endif

        if nelem(components) == 1
            ret = seas
            break
        endif
        ret = (i > 1) ? diagcat(ret, seas) : seas
    endloop

    return ret
end function

function matrix Zmat (const bundle self)
    /* Construct measurement equation matrix. */

    matrix Z

    # trend component
    if self.type_slope == "none"
        Z = {1}
    else
        Z = { 1; 0 }
    endif

    Z |= Zseasonals(self)

   return Z
end function


function bundle create_model_object (const bundle self)
    /* Create model object by means of the built-in ksetup() function. */

    # TODO: Why do we initiate Q by zeros? We already have a self.Qmat?
    return ksetup(self.depvar, self.Zmat, self.Tmat,
                  zeros(self.nStates, self.nStates))
end function


function matrix get_initial_state (const bundle Model, const bundle self)
    /* Get initial state.
    return: matrix, initialized states. */

    # --- experimental -----------------
    # in the future, we may want to set the initial state for the
    # level as an extra parameter for mle

    matrix ret = zeros(self.nStates, 1)
    ret[1] = meanc(self.depvar[1:$pd])

    if self.verbose > 1
        printf "Initial state:\n%g\n", ret
    endif

    return ret
end function
