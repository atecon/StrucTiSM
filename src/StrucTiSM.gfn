<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="StrucTiSM" needs-time-series-data="true" minver="2020c" lives-in-subdir="true">
<author email="r.lucchetti@univpm.it">Riccardo &quot;Jack&quot; Lucchetti and Sven Schreiber</author>
<version>1.0</version>
<date>2022-09-26</date>
<description>Harvey-style Structural Time Series Models</description>
<tags>C22 C52</tags>
<label>Structural TS</label>
<menu-attachment>MAINWIN/Model/TSModels</menu-attachment>
<help>
pdfdoc:StrucTiSM.pdf
</help>
<data-files count="1">
examples </data-files>
<depends count="1">
extra </depends>
<gretl-function name="STSM_GUImeta" type="bundle" pkg-role="gui-main">
 <params count="9">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="spec" type="int" min="1" max="3" default="1">
<description>Model</description>
<labels count="3">
"LL (local level)" "LLT (local linear trend)" "BSM (basic structural model)" </labels>
  </param>
  <param name="X" type="list" optional="true">
<description>Exogenous explanatory variables</description>
  </param>
  <param name="custom" type="bool" default="0">
<description>Custom model</description>
  </param>
  <param name="trend" type="int" min="1" max="2" default="1">
<description>Custom Trend</description>
<labels count="2">
"Stochastic" "Deterministic" </labels>
  </param>
  <param name="slope" type="int" min="0" max="2" default="1">
<description>Custom Slope</description>
<labels count="3">
"None" "Stochastic" "Deterministic" </labels>
  </param>
  <param name="seas" type="int" min="0" max="3" default="0">
<description>Custom Seasonal</description>
<labels count="4">
"None" "Stochastic (trig)" "Stochastic (dummies)" "Deterministic" </labels>
  </param>
  <param name="epsilon" type="bool" default="1">
<description>Custom Irregular</description>
  </param>
  <param name="fchoriz" type="int" min="0" default="0">
<description>Forecast sample end range</description>
  </param>
 </params>
<code>/*
New in 0.6: fchoriz: this range at the end is reserved for the forecasts, i.e. the currently active sample is shortened for estimation.
*/
# usual settings (LLT baseline)
# override for some specs
if !custom
  if spec == 1	# LL
    epsilon = 1
    trend   = 1
    slope   = 0
    seas    = 0
  elif spec == 2	# LLT
    epsilon = 1
    trend   = 1
    slope   = 1
    seas    = 0
  elif spec == 3 # BSM
    epsilon = 1
    trend   = 1
    slope   = 1
    seas    = 2
  endif
endif
if fchoriz &amp;&amp; $nobs &gt; fchoriz
  # first grab all exogenous values including for the fcast horizon
  # before we shorten the sample
  matrix fullmX = {}
  if nelem(X)
    fullmX = {X}
  endif
  # reserve the sample end for forecasting
  smpl +0 -fchoriz
elif fchoriz
  funcerr &quot;Not enough obs for chosen forecast horizon!&quot;
endif
bundle model = STSM_setup(y, epsilon, trend, slope, seas, X)
if fchoriz
  # add the exogenous values including out-of-sample
  # for potential forecasting (can be empty)
  matrix model.fullmX = fullmX
endif
if model.err
  printf &quot;Error: %s\n&quot;, errmsg(model.err)
else
  # this must be done by hand
  model.depvarname = argname(y)
  model.err = STSM_estimate(&amp;model)
endif
if fchoriz
  smpl --full
  STSM_fcast(&amp;model, fchoriz)
  smpl $t2-fchoriz+1 $t2
  series serfc = model.fcast	# workaround, directly to bundle gives error
  series serfcv = model.fcastvar
  series model.serfc = serfc
  series model.serfcv = serfcv
endif
return model
</code>
</gretl-function>
<gretl-function name="STSM_GUIplot" type="void" pkg-role="bundle-plot">
 <params count="2">
  <param name="model" type="bundleref"/>
  <param name="ptype" type="int" min="1" max="2" default="1">
<description>Plot type</description>
<labels count="2">
"Estimation results" "Forecasts" </labels>
  </param>
 </params>
<code>scalar ini = model.ini
scalar fin = model.fin
if ptype == 2 &amp;&amp; !inbundle(model, &quot;fcast&quot;)
  funcerr &quot;No forecast results to plot&quot;
endif
smpl ini fin
seasonal = model.seasonal &gt; 0
## set up the series to be plotted
list G = null
string sername = model.depvarname
G += genseries(sername, model.depvar * model.scale)
list comps = STSM_components(model)
if ptype == 1
  string trendname = sername  ~ &quot;_level&quot;
  if model.nexog &gt; 0
    string exoname = sername  ~ &quot;_exo&quot;
    series @trendname += @exoname
  endif
  G += @trendname
elif ptype == 2
  fin += rows(model.fcast)
  smpl ini fin
  string fcsername = sername~ &quot;_fc&quot;
  # series @fcsername = model.serfc
  G += genseries(fcsername, model.serfc) # @fcsername
  series fcse = sqrt(model.serfcv)
else
  funcerr &quot;shouldn't happen&quot;
endif
## And do the plot
if !seasonal &amp;&amp; ptype == 1 # (seasonal plot not -yet?- supported for FC)
  plot G
    options time-series with-lines single-yaxis
  end plot --output=display
elif ptype == 2
  plot G
    options time-series with-lines single-yaxis
    literal set title &quot;Out-of-sample forecast with 95% confidence band&quot;
    options band=@fcsername,fcse,1.96 band-style=fill
  end plot --output=display
else	# seasonal ptype==1
  string seasname = sername  ~ &quot;_seas&quot;
  seas_plot(G, @seasname, sername)
endif
</code>
</gretl-function>
<gretl-function name="STSM_setup" type="bundle">
 <params count="3">
  <param name="y" type="series" const="true">
<description>Dependent variable</description>
  </param>
  <param name="model" type="bundle" optional="true" const="true"/>
  <param name="xlist" type="list" optional="true"/>
 </params>
<code>/* Main function for setting up the model. */
set skip_missing off
bundle self = default_model_bundle()
if exists(model)
  self = model + self
endif
check_seasonality(&amp;self)
scalar self.n_seasonal_components = nelem(getkeys(self.seasonal))
string self.depvarname = !strlen(argname(y)) ? &quot;Y&quot; : argname(y)
xlist -= const # just in case
self = self + get_sample_details(y, xlist)
errorif(self.sample_start_index == self.sample_end_index, &quot;No effective observations available&quot;)
smpl self.sample_start_index self.sample_end_index
self.T = self.sample_end_index - self.sample_start_index + 1
self.sample_string = get_sample_string(self.sample_start_index, self.sample_end_index)
matrix self.depvar = {scale_series(y, &amp;self)}
get_xlist_details(xlist, &amp;self)
self.special_case_id = get_special_case_id(self)
prepare_system_matrices(&amp;self)
return self
</code>
</gretl-function>
<gretl-function name="STSM_estimate" type="scalar">
 <params count="3">
  <param name="self" type="bundleref"/>
  <param name="mapping" type="int" min="0" max="2" default="1"/>
  <param name="vcvmethod" type="int" min="0" max="2" default="1"/>
 </params>
<code>/* Main function for estimation of the specified model. */
# mapping: Reparametrisation (0 = Variances, 1 = Std. Dev (def), 2 = log)
# vcvmethod: 0 = opg, 1 = Hessian (def), 2 = robust
smpl self.sample_start_index self.sample_end_index
set warnings off
scalar has_exog = (self.nexog &gt; 0)
self.mapping = mapping
if self.special_case_id
  estimate_special_case(&amp;self)
  return FALSE
endif
# FIXME: The following part is untested, yet!
errorif(self.nVar == 0 &amp;&amp; self.error_in_obseq == FALSE, &quot;No variances to estimate!&quot;)
matrices SysMat = self.SysMat
# parameters to estimate
if mapping == 2
  matrix psi = zeros(nVar + self.error_in_obseq, 1)
  stdveps = 0
else
  a = 4
  matrix psi = ones(nVar + self.error_in_obseq, 1) .* a
  stdveps = a
endif
if verbose == 0 || verbose == 1
  setopt mle --quiet
elif verbose == 2
  setopt mle --verbose
endif
if vcvmethod == 1
  setopt mle --hessian
elif vcvmethod == 2
  setopt mle --robust
endif
# Define the model ------------------------------------------------------
bundle Model = ksetup(mod.depvar, SysMat[3], SysMat[1], zeros(nStates, nStates))
matrix R = SysMat[2]
# --- experimental -----------------
# in the future, we may want to set the initial state for the
# level as an extra parameter for mle
Model.inistate = zeros(nStates, 1)
Model.inistate[1] = meanc(mod.depvar[1:$pd])
# printf &quot;inistate:\n%g\n&quot;, Model.inistate
# ---------------------------------
if has_exog &gt; 0
  matrix y = mod.depvar
  matrix X = mod.mX
  Model.obsx = X
  matrix beta = mols(diff(y), diff(X)) #.* scale
  psi = psi | beta
endif
# ML estimation ---------------------------------------------------------
# test run
err = inject(psi, &amp;Model, self.error_in_obseq, nVar, R, mapping, nexog)
err = err || kfilter(&amp;Model)
errorif( err, &quot;ML init failed!&quot;)
# return 2 # E_DATA
# else
if verbose &gt; 1
  printf &quot;Init OK\n&quot;
endif
series ll = Model.llt
# endif
set lbfgs on # seems to perform better than plain BFGS
catch mle ll = err ? NA : misszero(ll)
  err = inject(psi, &amp;Model, self.error_in_obseq, nVar, R, mapping, nexog)
  err = err || kfilter(&amp;Model)
  series ll = Model.llt
  params psi
end mle
scalar err1 = $error
if err1
  printf &quot;error! %s\n&quot;, errmsg(err1)
  return err1
endif
# --- mle done; now pack the results nicely ---------------------
matrices results = adjust($coeff, $vcv, scale, mapping, nexog)
mod.coeff = results[1]
mod.vcv = results[2]
mod.llt = {ll} - ln(scale)
if self.verbose
  STSM_printout(&amp;self)
endif
scalar err = ksmooth(&amp;Model)
errorif(err, sprintf(&quot;Smoothing failed! (%s)&quot;, errmsg(err)))
self.St = Model.state * self.y_scaling_factor
# take care of the unobserved components
J = Xtract(self.slope, self.seasonal, self.pd)
k = add_states_to_model(&amp;mod, J)
J = qformvech(J)
dg = diag(unvech(seq(1,cols(J))'))
self.stSE = sqrt(Model.stvar * J[,dg]) * scale
return 0
</code>
</gretl-function>
<gretl-function name="STSM_printout" type="void" pkg-role="bundle-print">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Print results */
printf &quot;\nStructural model for %s, %s (T = %d)\n&quot;, self.depvarname, self.sample_string, self.T
if self.special_case_id
  print &quot;Estimation carried out via OLS.&quot;
else
  scalar mapping = self.mapping
  strings parameter_labels = get_parameter_labels(self)
  matrix cf = self.coeff ~ sqrt(diag(self.vcv))
  modprint cf parameter_labels
  # TODO: Is this still needed?
  # maps = defarray(&quot;Variances&quot;, &quot;Std. Dev&quot;, &quot;log&quot;)
  # printf &quot;mapping = %s, scale = %g\n&quot;, maps[mapping+1],\
  #   self.y_scaling_factor
  printf &quot;Average log-likelihood = %g\n&quot;, meanc(self.llt)
endif
print_specification(self)
</code>
</gretl-function>
<gretl-function name="STSM_components" type="list">
 <params count="2">
  <param name="self" type="bundle"/>
  <param name="stderrs" type="bool" default="0"/>
 </params>
<code>/* Extract the estimated components. */
list components = null
if !inbundle(self, &quot;component_names&quot;)
  printf &quot;Warning: It seems that bundle '%s' doesn't contain the states.\n&quot;, argname(self)
  return components
endif
scalar n_cdesc = nelem(self.stSE)
loop i=1..nelem(self.component_names)
  string vname = self.component_names[i]
  string desc = self.component_descriptions[i]
  components += genseries(self.component_names[i], self[vname])
  setinfo @vname --description=&quot;@desc&quot;
  # don't do irregular &amp; exog
  if stderrs == TRUE &amp;&amp; self.special_case_id == FALSE &amp;&amp; ( i &lt;= n_cdesc)
    vname += &quot;_se&quot;
    components += genseries(vname, self.stSE[,i])
    setinfo @vname --description=&quot;@desc (s.e.)&quot;
  endif
endloop
return components
</code>
</gretl-function>
<gretl-function name="STSM_fcast" type="scalar">
 <params count="4">
  <param name="mod" type="bundleref"/>
  <param name="horizon" type="int" default="0"/>
  <param name="verbose" type="bool" default="1"/>
  <param name="do_states" type="bool" default="0"/>
 </params>
<code># This function computes forecasts by setting up an auxiliary
# Kalman bundle in which we append a vector of NAs at the end of the
# dependent variable and then we run the forward filter; the
# forecasts are then computed from the filtered states.
#
# If (do_states), then store the forecast states too (default: don't)
#
# The case with exogenous variables is a little different because we
# need the future values of those. So then we require that the
# available sample is larger than the original estimation sample.
scalar err = 0
# set forecasting horizon to a sensible default if not passed by the user
if !exists(horizon) || horizon == 0
  horizon = set_horizon()
endif
if mod.special_case
  # handle special cases first
  err = fcast_special_case(&amp;mod, horizon, do_states)
  if verbose
    fcast_printout(mod)
  endif
  return err
endif
if mod.nexog &gt; 0
  # Old:
  # printf &quot;Forecasting with exogenous variable not supported yet\n&quot;
  errorif( $t2 &lt; mod.fin + horizon, sprintf(&quot;need expanded sample (by %d periods &quot;, horizon) ~ &quot;to access exogenous values for forecasting&quot;)
  if !inbundle(mod, &quot;fullmX&quot;) # could already be done by GUI function
    matrix mod.fullmX = {mod.X}
    # cut to desired forecasting horizon if sample is longer
    # (here we kind of hope that the user didn't mess with the
    # sample start, i.e. only the end can be shifted!)
    mod.fullmX = mod.fullmX[1: mod.T + horizon, ]
  endif
  errorif( rows(mod.fullmX) != rows(mod.mX) + horizon, &quot;length of exo values (fullmX) doesn't match horizon&quot;)
endif
# does mod contain estimates at all?
errorif( !inbundle(mod, &quot;compnames&quot;), sprintf( &quot;It seems that bundle %s doesn't contain the states\n&quot;, argname(mod)))
#    err = 30 # E_BADSTAT
#    return err
# endif
###
# now re-pack stuff into a temporary Kalman bundle
###
# matrices M     = mod.SysMat
# scalar mapping = mod.mapping
# scalar scale   = mod.scale
# scalar self.error_in_obseq = mod.error_in_obseq
# scalar n       = mod.nVar
# matrix depvar  = mod.depvar
# set up the ssm from scratch (Sven: but why actually??)
matrix F = mod.SysMat[1] # transition matrix
matrix R = mod.SysMat[2] # map from shocks to state innovations
matrix H = mod.SysMat[3] # observation matrix
scalar r = rows(R)
matrix Sigma = zeros(r, r)
bundle kmod = ksetup(mod.depvar, H, F, Sigma)
kmod.nexog = mod.nexog
kmod.scale = mod.scale
if ok(mod.nVar) &amp;&amp; mod.nVar &gt; 0 # ok(n) &amp;&amp; n &gt; 0
  # matrix coeff = mod.coeff
  err = inject(mod.coeff, &amp;kmod, mod.error_in_obseq, mod.nVar, R, mod.mapping, mod.nexog)
  # (also defines kmod.obsxmat if applicable)
  if mod.nexog
    # copy the out-of-sample exo regressors
    matrix kmod.fullmX = mod.fullmX
  endif
endif
# perform the forecast and copy the results back to the original bundle
# bwrite(kmod, &quot;/tmp/before.xml&quot;)   # debugging
err = kfcast(&amp;kmod, do_states, horizon)
# bwrite(kmod, &quot;/tmp/after.xml&quot;)    # debugging
if !err
  mod = mod + defbundle(&quot;fcast&quot;, kmod.fcast * mod.scale, &quot;fcastvar&quot;, kmod.fcastvar)
  if do_states
    # also store forecasts for the unobserved components
    J = mod.scale * Xtract(mod.slope, mod.seasonal, mod.pd)
    sf = kmod.sfcast * J
    sv = {}
    loop i = 1 .. horizon
      V = unvech(kmod.sfcastvar[i,]')
      sv |= vech(qform(J', V))'
    endloop
    mod = mod + defbundle(&quot;sfcast&quot;, sf, &quot;sfcastvar&quot;, sv)
  endif
endif
if verbose
  fcast_printout(mod)
endif
return err
</code>
</gretl-function>
<gretl-function name="LLT" type="list">
 <params count="3">
  <param name="y" type="series"/>
  <param name="se" type="bool" default="0"/>
  <param name="out" type="bundleref" optional="true"/>
 </params>
<code>mod = STSM_setup(y, 1, 1, 1, 0)
list ret = null
if mod.err
  printf &quot;%s\n&quot;, errmsg(mod.err)
  return ret
endif
mod.depvarname = argname(y)
mod.err = STSM_estimate(&amp;mod)
if !mod.err
  list ret = STSM_components(mod, se)
endif
if exists(out)
  out = mod
endif
return ret
</code>
</gretl-function>
<gretl-function name="BSM" type="list">
 <params count="3">
  <param name="y" type="series"/>
  <param name="se" type="bool" default="0"/>
  <param name="out" type="bundleref" optional="true"/>
 </params>
<code>mod = STSM_setup(y, 1, 1, 1, 2)
list ret = null
if mod.err
  printf &quot;%s\n&quot;, errmsg(mod.err)
  return ret
endif
mod.depvarname = argname(y)
mod.err = STSM_estimate(&amp;mod)
if !mod.err
  list ret = STSM_components(mod, se)
endif
if exists(out)
  out = mod
endif
return ret
</code>
</gretl-function>
<gretl-function name="prepare_system_matrices" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Call functions preparing various system matrices. */
if self.special_case_id
  matrices self.SysMat = array(0)
else
  initialize_system_matrices(&amp;self)
endif
</code>
</gretl-function>
<gretl-function name="Qseasonals" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Call actual function. */
matrix ret
strings components = getkeys(self.seasonal)
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  scalar k = self.seasonal[&quot;@key&quot;].frequency - 1
  if self.seasonal[&quot;@key&quot;].type == &quot;trigonometric&quot; &amp;&amp; self.seasonal[&quot;@key&quot;].stochastic == TRUE
    matrix seas = diagcat(ret, mshape({1,0}, k, 1))
  elif self.seasonal[&quot;@key&quot;].type == &quot;trigonometric&quot; &amp;&amp; self.seasonal[&quot;@key&quot;].stochastic == FALSE
    # TODO: Can we implement this?
    errorif(TRUE, &quot;Non-stochastic trigonometric seasonality not supported.&quot;)
  elif self.seasonal[&quot;@key&quot;].type == &quot;dummy&quot; &amp;&amp; self.seasonal[&quot;@key&quot;].stochastic == TRUE
    matrix seas = diagcat(ret, 1 | zeros(k-1, 1))
  elif self.seasonal[&quot;@key&quot;].type == &quot;dummy&quot; &amp;&amp; self.seasonal[&quot;@key&quot;].stochastic == FALSE
    matrix seas = diagcat(ret, zeros(k, 1))
  endif
  if nelem(components) == 1
    ret = seas
    break
  endif
  ret = (i &gt; 1) ? diagcat(ret, seas) : seas
endloop
return ret
</code>
</gretl-function>
<gretl-function name="Qmat" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* This function returns a matrix mapping the stochastic shocks into the
state transition variance matrix: it has as many rows as the dimension
of the state vector and as many columns as the number of variances
to estimate. */
matrix ret
if self.type_trend == &quot;stochastic&quot;
  ret = diagcat(ret, 1)
elif self.type_trend == &quot;deterministic&quot;
  ret = diagcat(ret, 0)
endif
if self.type_slope == &quot;stochastic&quot;
  ret = diagcat(ret, 1)
elif self.type_slope == &quot;deterministic&quot;
  ret = diagcat(ret, 0)
else
  # nothing to do if no slope is requested
endif
ret = diagcat(ret, Qseasonals(self))
ret = selifc(ret, maxc(ret) .&gt; 0)
return ret
</code>
</gretl-function>
<gretl-function name="trigonometric_seasonality" type="matrix" private="1">
 <params count="1">
  <param name="pd" type="scalar" const="true"/>
 </params>
<code>/* Compute BSM transition matrix for trigonometric seasonality.
return: type, description */
odd = pd % 2
dim = pd - 1
H = floor(pd/2) - 1 + odd
ret = zeros(dim, dim)
fin = 0
loop i = 1..H
  ini = fin+1
  fin = ini+1
  scalar c = cos(2*$pi * i/pd)
  scalar s = sin(2*$pi * i/pd)
  ret[ini:fin, ini:fin] = {c, s; -s, c}
endloop
if !odd
  ret[H*2 + 1, H*2 + 1] = -1
endif
return ret
</code>
</gretl-function>
<gretl-function name="dummy_seasonality" type="matrix" private="1">
 <params count="1">
  <param name="pd" type="scalar" const="true"/>
 </params>
<code>/* Compute BSM transition matrix for seasonal dummies.
return: type, description */
return -ones(1, pd-1) | (I(pd-2) ~ 0)
</code>
</gretl-function>
<gretl-function name="Tseasonals" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Call actual function to construct seasonals for T matrix. */
matrix ret
strings components = getkeys(self.seasonal)
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  if self.seasonal[&quot;@key&quot;].type == &quot;dummy&quot;
    matrix seas = dummy_seasonality(self.seasonal[&quot;@key&quot;].frequency)
  elif self.seasonal[&quot;@key&quot;].type == &quot;trigonometric&quot;
    matrix seas = trigonometric_seasonality(self.seasonal[&quot;@key&quot;].frequency)
  endif
  if nelem(components) == 1
    ret = seas
    break
  endif
  ret = (i &gt; 1) ? diagcat(ret, seas) : seas
endloop
return ret
</code>
</gretl-function>
<gretl-function name="Tmat" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Compile the transition matrix T. */
if self.type_slope != &quot;none&quot;
  ret = {1, 1; 0, 1}  # random-walk in beta
else
  ret = {1}
endif
if self.n_seasonal_components
  matrix seas = Tseasonals(self)
  ret = diagcat(ret, seas)
endif
return ret
</code>
</gretl-function>
<gretl-function name="initialize_system_matrices" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Construct all necessary system matrices and add to self. */
# int trend, int slope, int seasonal, scalar *nStates, scalar *nVar)
# Transition equation
matrix self.Tmat = Tmat(self)
scalar self.nStates = rows(self.Tmat)   # size of state vector
# Square matrix of variance
matrix self.Qmat = Qmat(self)
self.nVar = cols(self.Qmat)
# measurement equation: matrix of the state vector
matrix self.Zmat = Zmat(self)
if rows(self.Qmat) != self.nStates
  print_sanity_check_results(self)
endif
</code>
</gretl-function>
<gretl-function name="print_sanity_check_results" type="void" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Print details for debugging. */
printf &quot;Mismatch! (nStates = %d)\n&quot;, self.nStates
printf &quot;statemat (T):\n%5.1f\n&quot;, self.Tmat
printf &quot;Q:\n%5.1f\n&quot;, self.Qmat
printf &quot;obsmat (Z):\n%5.1f\n&quot;, self.Zmat
</code>
</gretl-function>
<gretl-function name="Zseasonals" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Call actual function. */
matrix ret
strings components = getkeys(self.seasonal)
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  scalar pd = self.seasonal[&quot;@key&quot;].frequency
  if self.seasonal[&quot;@key&quot;].type == &quot;dummy&quot;
    k = pd - 2
    matrix seas = 1 | zeros(k, 1)
  else
    k = pd - 1
    matrix seas = mshape({1,0}, $pd - 1, 1)
  endif
  if nelem(components) == 1
    ret = seas
    break
  endif
  ret = (i &gt; 1) ? diagcat(ret, seas) : seas
endloop
return ret
</code>
</gretl-function>
<gretl-function name="Zmat" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Construct measurement equation matrix. */
matrix Z
# trend component
if self.type_slope == &quot;none&quot;
  Z = {1}
else
  Z = { 1; 0 }
endif
Z |= Zseasonals(self)
return Z
</code>
</gretl-function>
<gretl-function name="default_model_bundle" type="bundle" private="1">
<code>/* Compile the default bundle holding model parameters */
bundle self = null
scalar self.err = FALSE
scalar self.verbose = TRUE
scalar self.error_in_obseq = TRUE          # formerly &quot;epsilon&quot;
string self.type_trend = &quot;deterministic&quot;   # {&quot;stochastic&quot; &quot;deterministic&quot;}
string self.type_slope = &quot;none&quot;  # {&quot;none&quot; &quot;stochastic&quot; &quot;deterministic&quot;}
scalar self.pd = $pd
bundle self.seasonal = null
#bundle self.seasonal.component_1 = null
#scalar self.seasonal.component_1.stochastic = FALSE
#string self.seasonal.component_1.type = &quot;dummy&quot;    # {&quot;dummy&quot;, &quot;trigonometric&quot;}
# scalar self.seasonal.component_1.frequency = $pd
scalar self.nStates = NA
scalar self.nVar = NA       # number of variances to estimate
scalar self.y_scaling_factor = NA
return self
</code>
</gretl-function>
<gretl-function name="check_seasonality" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Check if dataset has seasonality. If not, reset seasonal bundle. */
if $pd == 1
  print &quot;The dataset has no seasonality. Eventuall specified seasonality will be ignored.&quot;
  bundle self.seasonal = null
endif
</code>
</gretl-function>
<gretl-function name="get_sample_details" type="bundle" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="xlist" type="list" optional="true" const="true"/>
 </params>
<code>/* Get sample start and end.
return: bundle, holding index of start and end date */
bundle self
list Z = y xlist
series okobs = zeromiss(ok(Z))
scalar self.sample_start_index = xmax(firstobs(okobs), $t1)
scalar self.sample_end_index = xmin(lastobs(okobs), $t2)
return self
</code>
</gretl-function>
<gretl-function name="get_sample_string" type="string" private="1">
 <params count="2">
  <param name="start_index" type="int" const="true"/>
  <param name="end_index" type="int" const="true"/>
 </params>
<code>return sprintf(&quot;%s - %s&quot;, obslabel(start_index), obslabel(end_index))
</code>
</gretl-function>
<gretl-function name="stochastic_season_exists" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* code description
return: type, description */
scalar ret = 0
strings components = getkeys(self.seasonal)
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  if self.seasonal[&quot;@key&quot;].stochastic == TRUE
    ret++
  endif
endloop
return (ret &gt; 0) ? TRUE : FALSE
</code>
</gretl-function>
<gretl-function name="get_xlist_details" type="void" private="1">
 <params count="2">
  <param name="xlist" type="list"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Add some details about xlist to bundle. */
scalar self.nexog = nelem(xlist)
if self.nexog
  list self.xlist = xlist
  string self.xnames = varname(xlist)
  matrix self.mX = {xlist}
endif
</code>
</gretl-function>
<gretl-function name="set_horizon" type="scalar" private="1">
<code># some sensible defaults
if $pd == 1
  horizon = 10
elif ($pd == 4)
  horizon = 8
elif ($pd == 5) || ($pd == 6) || ($pd == 7)
  horizon = 2 * $pd
elif ($pd == 12)
  horizon = 12
else
  horizon = $pd
endif
return horizon
</code>
</gretl-function>
<gretl-function name="reparm" type="matrix" private="1">
 <params count="3">
  <param name="psi" type="matrix" const="true"/>
  <param name="option" type="int" min="0" max="2" default="1"/>
  <param name="inverse" type="bool" default="0"/>
 </params>
<code>set warnings off
# this function returns _variances_ given params
# option: 0 = abs 1 = square 2 = exp
matrix ret = {}
if option == 1
  # what goes into mle is std. devs
  ret = inverse ? sqrt(psi) : psi.^2
elif option == 2
  # what goes into mle is log variances
  ret = inverse ? ln(psi) : exp(psi)
else
  # what goes into mle is variances
  ret = abs(psi)
endif
return ret
</code>
</gretl-function>
<gretl-function name="inject" type="scalar" private="1">
 <params count="7">
  <param name="theta" type="matrix"/>
  <param name="kmod" type="bundleref"/>
  <param name="eps" type="bool"/>
  <param name="nVar" type="scalar"/>
  <param name="R" type="matrix" const="true"/>
  <param name="mapping" type="scalar"/>
  <param name="nexog" type="scalar"/>
 </params>
<code># this function injects the mle parameters into the Kalman bundle,
# given the characteristics of the model; returns an error value
scalar err = 0
ini = 1
if eps
  kmod.obsvar = reparm(theta[1], mapping)
  ini++
endif
fin = ini + nVar - 1
kmod.statevar[diag] = R * reparm(theta[ini:fin], mapping)
if nexog &gt; 0
  ini = fin + 1
  fin = fin + nexog
  kmod.obsxmat = theta[ini:fin]
endif
return err
</code>
</gretl-function>
<gretl-function name="scale_series" type="series" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code># TODO: For now
self.y_scaling_factor = sd(y) / 100
series ret = y / self.y_scaling_factor
if self.verbose
  printf &quot;Info: Scale for dependent variable = %g\n&quot;, self.y_scaling_factor
endif
return ret
</code>
</gretl-function>
<gretl-function name="adjust" type="matrices" private="1">
 <params count="5">
  <param name="coeff" type="matrix"/>
  <param name="vcv" type="matrix"/>
  <param name="scale" type="scalar"/>
  <param name="mapping" type="int"/>
  <param name="nexog" type="scalar"/>
 </params>
<code># this function re-maps the parameters used in &quot;mle&quot; into standard
# deviations, in the orginal unit of measurement; ret[1] contains the
# parameters, ret[2] their vcv (computed via the delta method)
matrices ret = array(2)
k = rows(coeff) - nexog
vc = coeff[1:k]
se_unscaled = sqrt(reparm(vc, mapping))
ret[1] = se_unscaled * scale
# the Jacobian
if mapping == 0
  matrix J = 0.5 * scale ./ se_unscaled
elif mapping == 1
  matrix J = mshape(scale, k, 1)
elif mapping == 2
  matrix J = 0.5 .* ret[1]
endif
ret[2] = vcv[1:k,1:k] .* (J*J')
if nexog
  betas = coeff[k+1:k+nexog] * scale
  ret[1] |= betas
  ret[2] = diagcat(ret[2], scale^2 * vcv[k+1:k+nexog,k+1:k+nexog])
endif
return ret
</code>
</gretl-function>
<gretl-function name="get_seasonal_parameter_labels" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Construct parameter labels for seasonal components. */
strings components = getkeys(self.seasonal)
strings ret = array(nelem(components))
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  ret[i] = sprintf(&quot;Seasonal (%s, F=%.2f)&quot;, self.seasonal[&quot;@key&quot;].type, self.seasonal[&quot;@key&quot;].frequency)
endloop
return ret
</code>
</gretl-function>
<gretl-function name="get_parameter_labels" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Create array of parameter labels. */
strings ret = array(0)
if self.error_in_obseq
  ret += &quot;Irregular&quot;
endif
ret += sprintf(&quot;Trend (%s)&quot;, self.type_trend)
if self.type_slope != &quot;none&quot;
  ret += sprintf(&quot;Slope (%s)&quot;, self.type_slope)
endif
ret += get_seasonal_parameter_labels(self)
if self.nexog &gt; 0
  ret += self.xnames
endif
return ret
</code>
</gretl-function>
<gretl-function name="print_specification_seasonal" type="void" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Print specification for seasonals. */
strings components = getkeys(self.seasonal)
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  string s = self.seasonal[&quot;@key&quot;].stochastic == TRUE ? &quot;stochastic&quot; : &quot;deterministic&quot;
  printf &quot;, seasonal&quot;
  if nelem(components) &gt; 1
    printf &quot; (%d)&quot;, i
  endif
  printf &quot;: %s (%s, F=%.2f)&quot;, s, self.seasonal[&quot;@key&quot;].type, self.seasonal[&quot;@key&quot;].frequency
endloop
</code>
</gretl-function>
<gretl-function name="print_specification" type="void" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Print specification. */
printf &quot;\n\nSpecification:\n&quot;
printf &quot;================\n&quot;
printf &quot;Trend: %s&quot;, self.type_trend
printf &quot;, slope: %s&quot;, self.type_slope
print_specification_seasonal(self)
if self.error_in_obseq
  printf &quot;\n, irregular component&quot;
endif
printf &quot;\n\n&quot;
</code>
</gretl-function>
<gretl-function name="Xtract" type="matrix" private="1">
 <params count="3">
  <param name="slope" type="int"/>
  <param name="seasonal" type="int"/>
  <param name="pd" type="scalar"/>
 </params>
<code># this function creates an n x k matrix, which extracts
# the components to export from the state vector
# the level is always there, either deterministic or stochastic
matrix ret = {1}
if slope &gt; 0
  ret = diagcat(ret, 1)
endif
if seasonal == 1
  ret = diagcat(ret, mshape({1,0}, pd-1, 1))
elif seasonal == 2 || seasonal == 3
  ret = diagcat(ret, 1 | zeros(pd-2, 1))
endif
return ret
</code>
</gretl-function>
<gretl-function name="add_states_to_model" type="scalar" private="1">
 <params count="2">
  <param name="model" type="bundleref"/>
  <param name="J" type="matrix" const="true"/>
 </params>
<code># does model contain estimates at all?
if !inbundle(model, &quot;St&quot;)
  printf &quot;Error!\n&quot;
  return 0
endif
strings compnames = null
strings compdescs = null
scalar k = 1
scalar has_eps = model.epsilon
scalar ini = model.ini
scalar fin = model.fin
smpl ini fin
# initialise the &quot;residuals&quot;
if has_eps
  series eps = model.depvar * model.scale
endif
# &quot;name&quot; holds the outer name of the dependent variable
name = model.depvarname
nStates = model.nStates
pd = model.pd
matrix St = model.St * J
# do the level ---------------------------------------------
string sername = name ~ &quot;_level&quot;
genseries(sername, St[,1])
compnames += sername
compdescs += &quot;Trend level&quot;
model[sername] = @sername
if has_eps
  series eps -= @sername
endif
# do the slope, if present ---------------------------------
if model.slope == 1
  k++
  sername = name ~ &quot;_slope&quot;
  genseries(sername, St[,k])
  compnames += sername
  compdescs += &quot;Slope&quot;
  model[sername] = @sername
elif model.slope == 2
  # just skip the deterministic slope
  k++
endif
# do the seasonal, if present ------------------------------
if model.seasonal &gt;= 1
  k++
  # printf &quot;(seasonal) k = %d\n&quot;, k
  sername = name ~ &quot;_seas&quot;
  genseries(sername, St[,k])
  compnames += sername
  if model.seasonal == 1
    compdescs += &quot;Seasonal (with trigon. terms)&quot;
  elif model.seasonal &gt; 1
    compdescs += &quot;Seasonal (with dummies)&quot;
  endif
  model[sername] = @sername
  if has_eps
    series eps -= @sername
  endif
endif
# do the exogenous component, if present ---------------------
if model.nexog &gt;= 1
  k++
  nVar = model.nVar
  sername = name ~ &quot;_exo&quot;
  beta = model.coeff[has_eps + model.nVar + 1:]
  genseries(sername, model.mX * beta)
  compnames += sername
  compdescs += &quot;Exogenous&quot;
  model[sername] = @sername
  if has_eps
    series eps -= @sername
  endif
endif
# finalise the irregular component, if present --------------
if has_eps
  k++
  sername = name ~ &quot;_irreg&quot;
  genseries(sername, eps)
  compnames += sername
  compdescs += &quot;Irregular&quot;
  model[sername] = @sername
endif
# Add the names of the newly created series to the bundle
strings model.compnames = compnames
strings model.compdescs = compdescs
return k
</code>
</gretl-function>
<gretl-function name="get_special_case_id" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Check for a few special cases that need no numerical optimisation */
scalar ret = 0
stochastic_trend = (self.type_trend == &quot;stochastic&quot;)
stochastic_slope = (self.type_slope == &quot;stochastic&quot;)
stochastic_season = stochastic_season_exists(self)
# TODO: I think the if-conditions may be simplified
if !(stochastic_trend || stochastic_slope || stochastic_trend)
  if stochastic_trend == FALSE &amp;&amp; self.type_slope == &quot;none&quot; &amp;&amp; self.n_seasonal_components == 0
    # case 1: just a constant + irregular
    ret = 1
  elif stochastic_trend == FALSE &amp;&amp; self.type_slope == &quot;deterministic&quot; &amp;&amp; self.n_seasonal_components == 0
    # case 2: constant + trend + irregular
    ret = 2
  elif stochastic_trend == FALSE &amp;&amp; self.type_slope == &quot;none&quot; &amp;&amp; stochastic_season == FALSE
    # case 3: constant + seasonal dummies + irregular
    ret = 3
  elif stochastic_trend == FALSE &amp;&amp; self.type_slope == &quot;deterministic&quot; &amp;&amp; stochastic_season == FALSE
    # case 4: constant + trend + seasonal dummies + irregular
    ret = 4
  endif
endif
return ret
</code>
</gretl-function>
<gretl-function name="special_case_seasonals" type="matrix" private="1">
 <params count="2">
  <param name="self" type="bundle" const="true"/>
  <param name="trend" type="matrix" const="true"/>
 </params>
<code>/* Construct seasonals for estimating special cases.
return: type, description */
matrix X
strings components = getkeys(self.seasonal)
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  frq = self.seasonal[&quot;@key&quot;].frequency
  matrix seas = (trend % frq) .= seq(1, (frq-1))
  X ~= seas - (1 / frq)
endloop
return X
</code>
</gretl-function>
<gretl-function name="special_case_seasonals_states" type="matrix" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="X" type="matrix" const="true"/>
  <param name="coeff" type="matrix" const="true"/>
 </params>
<code>/* Compute states for each seasonal component for the special case.
return: matrix, Each column holds one of the (ordered by frequency) seasonal component. */
strings components = getkeys(self.seasonal)
matrix ret = mshape(NA, self.T, nelem(components))
scalar init = 1
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  if i == 1
    scalar ende = self.seasonal[&quot;@key&quot;].frequency - 1
  else
    init = 1 + ende
    scalar ende = init + self.seasonal[&quot;@key&quot;].frequency - 2
  endif
  ret[,i] = X[,init:ende] * coeff[init:ende]
endloop
return ret
</code>
</gretl-function>
<gretl-function name="special_case_state" type="matrix" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="X" type="matrix" const="true"/>
  <param name="coeff" type="matrix" const="true"/>
 </params>
<code>/* Compute state for special cases.
return: matrix, Holds the estimated (un-scaled) components such as level etc. */
matrix state
if self.special_case_id == 1
  # no seasonal component(s)
  state = X * coeff
elif self.special_case_id == 2
  # no seasonal component(s)
  state = X[,1:2] * coeff[1:2]
  state ~= mshape(coeff[2], self.T, 1)
elif self.special_case_id == 3
  state = mshape(coeff[1], self.T, 1)
  scalar init_column_seasonal = 2
elif self.special_case_id == 4
  state = X[,1:2] * coeff[1:2]
  state ~= mshape(coeff[2], self.T, 1)
  scalar init_column_seasonal = 3
endif
if self.special_case_id == 3 || self.special_case_id == 4
  # Add seasonal components
  state ~= special_case_seasonals_states(self, X[, init_column_seasonal:], coeff[init_column_seasonal:])
endif
return state
</code>
</gretl-function>
<gretl-function name="special_case_seasonal_component" type="void" private="1">
 <params count="2">
  <param name="self" type="bundleref"/>
  <param name="states" type="matrix" const="true"/>
 </params>
<code>/* Add seasonal components as series to bundle. */
strings components = getkeys(self.seasonal)
loop i=1..nelem(components)
  string key = sprintf(&quot;component_%d&quot;, i)
  scalar frq = ceil(self.seasonal[&quot;@key&quot;].frequency)
  string vname = sprintf(&quot;%s_seas_%d&quot;, self.depvarname, frq)
  self.component_names += vname
  self.component_descriptions += sprintf(&quot;Seasonal Freq = %g (deterministic)&quot;, self.seasonal[&quot;@key&quot;].frequency)
  genseries(vname, states[,i])
  self[vname] = @vname
endloop
</code>
</gretl-function>
<gretl-function name="handle_special_case" type="matrix" private="1">
 <params count="2">
  <param name="self" type="bundle" const="true"/>
  <param name="coeff" type="matrixref"/>
 </params>
<code>/* Return residuals and state vectors. */
matrix X = ones(self.T, 1)
matrix trend = seq(1, self.T)'
matrix uhat = {}
if (self.special_case_id == 2) || (self.special_case_id == 4)
  X ~= trend
endif
if (self.special_case_id == 3) || (self.special_case_id == 4)
  X ~= special_case_seasonals(self, trend)
endif
matrix coeff = mols(self.depvar, X, &amp;uhat)
matrix state = special_case_state(self, X, coeff)
return uhat ~ state
</code>
</gretl-function>
<gretl-function name="add_states_special" type="scalar" private="1">
 <params count="2">
  <param name="states" type="matrix"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* */
strings self.component_names = null
strings self.component_descriptions = null
scalar counter = 2
scalar self.nStates = cols(states) - 1
# irregular component
string vname = self.depvarname ~ &quot;_irreg&quot;
genseries(vname, states[,1])
self.component_names += vname
self.component_descriptions += &quot;Irregular&quot;
self[vname] = @vname  # store series
# level component
string vname = self.depvarname ~ &quot;_level&quot;
genseries(vname, states[,2])
self.component_names += vname
self.component_descriptions += &quot;Trend level&quot;
self[vname] = @vname
# slope component if present
if self.type_slope != &quot;none&quot;
  # if (self.special_case_id == 2) || (self.special_case_id  == 4)
  counter++
  vname = self.depvarname ~ &quot;_slope&quot;
  genseries(vname, states[,counter])
  self.component_names += vname
  self.component_descriptions += &quot;Slope&quot;
  self[vname] = @vname
endif
# seasonal component(s), if present
if self.n_seasonal_components
  # if (self.special_case_id == 3) || (self.special_case_id  == 4)
  scalar ini = counter + 1
  scalar ende = ini + self.n_seasonal_components - 1
  special_case_seasonal_component(&amp;self, states[, ini:ende])
  counter += self.n_seasonal_components
endif
# exogenous component, if present
# TODO: Add later
if 0
  counter++
  nVar = self.nVar
  vname = name ~ &quot;_exo&quot;
  beta = self.coeff[has_eps + self.nVar + 1:]
  genseries(vname, self.mX * beta)
  self.component_names += vname
  self.component_descriptions += &quot;Exogenous&quot;
  model[vname] = @vname
  if has_eps
    series eps -= @vname
  endif
endif
self.stSE = mshape(NA, self.T, counter)
return counter
</code>
</gretl-function>
<gretl-function name="estimate_special_case" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Call functions for estimating special case specifications which do not require numerical optimisation. */
matrix coeff = {}
# unscaled components
matrix components = handle_special_case(self, &amp;coeff)
matrix components *= self.y_scaling_factor
self.coeff = coeff
add_states_special(components, &amp;self)
if self.verbose
  STSM_printout(&amp;self)
endif
</code>
</gretl-function>
<gretl-function name="kfcast" type="scalar" private="1">
 <params count="3">
  <param name="kmod" type="bundleref"/>
  <param name="do_states" type="bool"/>
  <param name="horizon" type="scalar"/>
 </params>
<code>n = kmod.n
r = kmod.r
T0 = kmod.T
matrix y = kmod.obsy | mshape(NA, horizon, n)
matrix F = kmod.statemat
matrix H = kmod.obsymat
matrix Sigma = kmod.statevar
bundle tmp = ksetup(y, H, F, Sigma)
# insert in-sample as well as out-of-sample exogenous values
if kmod.nexog # does this also count a constant term??
  tmp.nexog = kmod.nexog
  matrix tmp.obsx = kmod.fullmX
  # the exogenous variables are unscaled, hence the correction
  matrix tmp.obsxmat = kmod.obsxmat ./ kmod.scale
endif
varepsilon = inbundle(kmod, &quot;obsvar&quot;) ? kmod.obsvar : 0
tmp.obsvar = varepsilon
err = kfilter(&amp;tmp)
if !err
  matrix Sf = tmp.state[T0+1:,]
  kmod.fcast = Sf * H
  # add the exo influence:
  if kmod.nexog
    kmod.fcast += tmp.obsx[T0+1:,] * tmp.obsxmat
  endif
  if do_states
    kmod.sfcast = Sf
  endif
  matrix Vhat = mshape(NA, horizon, round(n*(n+1)/2))
  if do_states
    matrix Omegahat = mshape(NA, horizon, round(r*(r+1)/2))
  endif
  loop i = 1 .. horizon
    Om = tmp.stvar[T0 + i,]
    if do_states
      Omegahat[i,] = Om
    endif
    Vhat[i,] =  qform(H', unvech(Om')) + varepsilon
  endloop
  kmod.fcastvar = Vhat
  if do_states
    kmod.sfcastvar = Omegahat
  endif
endif
return err
</code>
</gretl-function>
<gretl-function name="fcast_special_case" type="scalar" private="1">
 <params count="3">
  <param name="mod" type="bundleref"/>
  <param name="horizon" type="scalar"/>
  <param name="do_states" type="bool"/>
 </params>
<code># here we handle special cases by relying on ordinary (non-state space)
# inferential methods, eg ols
scalar err = 0
case = mod.special_case
matrix y = mod.depvar * mod.scale
scalar T = rows(y)
matrix e = {}
Th = T+horizon
matrix X = ones(Th,1)
if (case == 2) || (case==4)
  matrix X ~= seq(1, Th)' - Th/2
endif
if (case == 3) || (case==4)
  pd = mod.pd
  matrix X ~= mlag(seq(1,Th)' % pd .= 1, seq(0,pd-2))
endif
matrix b = mols(y, X[1:T,], &amp;e)
scalar v = meanc(e.^2)
matrix f = X[T+1:Th,]*b
matrix fv = v .* seq(1,horizon)'
mod.fcast = f
mod.fcastvar = fv
return err
</code>
</gretl-function>
<gretl-function name="fcast_printout" type="void" private="1">
 <params count="1">
  <param name="model" type="bundle"/>
 </params>
<code>if !exists(model.fcast)
  return
endif
matrix f = model.fcast
matrix s = sqrt(model.fcastvar)
string yname = model.depvarname
scalar h = rows(f)
printf &quot;\nOut of sample forecast for %s\n\n&quot;, yname
printf &quot;   horizon    forecast    std.err.\n\n&quot;
loop i = 1 .. h
  printf &quot;%10d%12.6g%12.6g\n&quot;, i, f[i], s[i]
endloop
print &quot;&quot;
</code>
</gretl-function>
<gretl-function name="purify" type="string" private="1">
 <params count="3">
  <param name="src" type="string"/>
  <param name="to_clean" type="strings"/>
  <param name="to_sub" type="strings"/>
 </params>
<code>string l = &quot;&quot;
string ret = &quot;&quot;
scalar n = nelem(to_clean)
if n == 0
  return src
endif
matrix len = zeros(1,n)
loop i = 1..n
  len[i] = strlen(to_clean[i])
endloop
loop while getline(src, l)
  drop = 0
  # printf &quot;%s\n&quot;, l
  loop i = 1..n
    scalar sl = len[i]
    m = strncmp(l, to_clean[i], sl)
    # printf &quot;\t%s -&gt; %d\n&quot;, to_clean[i], m
    if m == 0
      drop = i
      break
    endif
  endloop
  if drop
    if strlen(to_sub[i]) &gt; 0
      ret += sprintf(&quot;%s\n&quot;, to_sub[i])
    endif
  else
    ret += sprintf(&quot;%s\n&quot;, l)
  endif
endloop
return ret
</code>
</gretl-function>
<gretl-function name="seas_plot" type="void" private="1">
 <params count="3">
  <param name="y_lev" type="list"/>
  <param name="sea" type="series"/>
  <param name="name" type="string"/>
 </params>
<code>fname  = &quot;@dotdir/STSMtmp.gp&quot;
fname1 = &quot;@dotdir/STSMtmp1.gp&quot;
fname2 = &quot;@dotdir/STSMtmp2.gp&quot;
plot y_lev
  options time-series with-lines single-yaxis
  printf &quot;set title \&quot;%s and trend component\&quot;&quot;, name
end plot --output=@fname1
plot sea
  options time-series with-lines
  literal set title &quot;seasonal component&quot;
end plot --output=@fname2
buf = sprintf(&quot;set multiplot\nset size 1, 0.5\nset origin 0.0, 0.5\n&quot;)
buf ~= readfile(fname1)
buf ~= sprintf(&quot;\nset origin 0.0, 0.0\n&quot;)
f2 = readfile(fname2)
a = defarray(&quot;set ylabel&quot;)
b = defarray(&quot;unset ylabel&quot;)
buf ~= sprintf(&quot;%s\nunset multiplot\n&quot;, purify(f2, a, b))
outfile @fname --write
printf &quot;%s&quot;, buf
end outfile
gnuplot --input=@fname --output=display
</code>
</gretl-function>
<sample-script>
set verbose off
include StrucTiSM.gfn

scalar example = 2 # choose an example, from 1 to 7; -1 means &quot;all&quot;
scalar k = 1
bundle SSmod = null

###
### Example 1: The Local Level Model
###

if example == k || example == -1
    open nile.gdt --quiet --preserve

    # this is the &quot;Local Level Model&quot;; it corresponds to
    #
    ## epsilon = 1
    ## trend = 1
    ## slope = 0
    ## seasonal = 0

    epsilon = TRUE
    trend = 1
    slope = 0
    seasonal = 1

    model = STSM_setup(nile, epsilon, trend, slope, seasonal)

    scalar err = STSM_estimate(&amp;model)
    list comps = STSM_components(model)
    series level_se = model.stSE[,1]
    gnuplot nile nile_level --time-series --with-lines \
      --band=nile_level,level_se,1.96 \
      --band-style=fill --output=display
endif
k++

###
### Example 2: The Local Linear Trend Model
###

if example == k || example == -1
    open bikesharing.gdt --quiet --preserve

    bundle self = _(error_in_obseq = TRUE) #,\
                    #type_trend = &quot;stochastic&quot;)

    /*bundle self.seasonal = null
    self.seasonal.component_1 = _(stochastic = FALSE,\
                                  type = &quot;dummy&quot;,\
                                  frequency = 7)
    self.seasonal.component_2 = _(stochastic = FALSE,\
                                  type = &quot;trigonometric&quot;,\
                                  frequency = 365)*/

    model = STSM_setup(cnt, self)
    scalar err = STSM_estimate(&amp;model)
    list comps = STSM_components(model)
    scatters cnt comps --with-lines --output=display
endif
k++

if example == k || example == -1
    open australia.gdt --quiet --preserve

    # this is the &quot;Local Linear Trend Model&quot;; it corresponds to
    #
    ## epsilon = 1
    ## trend = 1
    ## slope = 1
    ## seasonal = 0
    #
    # the example is the same as in Ignacio's LLTestim sample script

    epsilon = TRUE
    trend = 1
    slope = 0
    seasonal = 1

    model = STSM_setup(IAU, epsilon, trend, slope, seasonal)
    scalar err = STSM_estimate(&amp;model)
    list comps = STSM_components(model)
    scatters IAU comps --with-lines --output=display
endif
k++

###
### Example 3: The Basic Structural Model
###

if example == k || example == -1
    open data9-3.gdt --quiet --preserve

    # this is the &quot;Basic Structural Model&quot;; it corresponds to
    #
    ## epsilon = 1
    ## trend = 1
    ## slope = 1
    ## seasonal = 2
    #
    # the example is the same as in Ignacio's BSMestim sample script

    epsilon = 1   # boolean
    trend = 1     # 1: stochastic, 2: deterministic
    slope = 1     # 0: none, 1: stochastic, 2: deterministic
    seasonal = 2  # 0: none, 1: stochastic (trig), 2: stochastic (dums), 3: deterministic dums

    model = STSM_setup(reskwh, epsilon, trend, slope, seasonal)
    scalar err = STSM_estimate(&amp;model)
    list comps = STSM_components(model)
    comps -= reskwh_slope
    scatters reskwh comps --with-lines --output=display
endif
k++

###
### Example 4: The BSM on the &quot;airline&quot; data, with a few NAs
###

if example == k || example == -1
    open bjg.gdt --quiet --preserve

    loop i = 30..37
        lg[i] = NA
    endloop
    verbose = 3

    epsilon = 1   # boolean
    trend = 1     # 1: stochastic, 2: deterministic
    slope = 1     # 0: none, 1: stochastic, 2: deterministic
    seasonal = 2  # 0: none, 1: stochastic (trig), 2: stochastic (dums), 3: deterministic dums

    model = STSM_setup(lg, epsilon, trend, slope, seasonal)

    verbose = 1
    mapping = 2
    scalar err = STSM_estimate(&amp;model, verbose, mapping)
    list comps = STSM_components(model)
    scatters lg comps --with-lines --output=display
endif
k++

###
### Example 5: Daily data, with exogenous variables
###

if example == k || example == -1
    open gretl_dnl.gdt --quiet --preserve --frompkg=StrucTiSM
    y = log(dnl)

    # create Fourier regressors with yearly period
    series tt = time*2*$pi/365.25
    list FOU = null
    loop i = 1..3
        series cos$i = cos(i * tt)
        series sin$i = sin(i * tt)
        list FOU += cos$i sin$i
    endloop

    epsilon = 1   # boolean
    trend   = 1   # 1: stochastic, 2: deterministic
    slope   = 0   # 0: none, 1: stochastic, 2: deterministic
    seasonal = 3  # 0: none, 1: stochastic (trig), 2: stochastic (dums), 
                  #   3: deterministic dums

    model = STSM_setup(y, epsilon, trend, slope, seasonal, FOU)

    verbose = 1
    mapping = 0
    scalar err = STSM_estimate(&amp;model, verbose, mapping)
    list comps = STSM_components(model)
    scatters y comps --with-lines --output=display
endif
k++

###
### Example 6: Custom model with a largish dataset and subsampling
###

if example == k || example == -1
    clear --dataset
    open fedstl.bin
    data paynsa
    logs paynsa

    smpl 1960:1 ;

    m   = STSM_setup(l_paynsa,0,1,0,2)
    err = STSM_estimate(&amp;m)
    list comps = STSM_components(m)
    scatters l_paynsa comps --with-lines --output=display
endif
k++

###
### Example 7: Shortcut usage and forecasting
###

if example == k || example == -1
    open data9-9.gdt --quiet
    horizon = 8

    smpl ; -horizon

    bundle mod = null
    comps = BSM(nocars, 0, &amp;mod)
    scalar err = STSM_fcast(&amp;mod, horizon)

    smpl full

    series nocars_f = mshape(NA, $nobs-horizon, 1) | mod.fcast
    series fse  = zeros($nobs-horizon, 1) | sqrt(mod.fcastvar)
    list ToPlot = nocars nocars_f

    plot ToPlot
        options time-series with-lines
        literal set title &quot;Actual vs out-of-sample forecast with 90% confidence band&quot;
        options band=nocars_f,fse,1.65 band-style=fill
    end plot --output=display

endif
</sample-script>
</gretl-function-package>
</gretl-functions>
