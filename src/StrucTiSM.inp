include StateSpace.inp
include utils.inp
include special_cases.inp
include forecast.inp
include StrucTiSM_GUI.inp


function bundle STSM_setup (const series y "Dependent variable",
                            const bundle model[null],
                            list xlist[null])
    /* Main function for setting up the model. */

    set skip_missing off

    bundle self = default_model_bundle()
    if exists(model)
        self = model + self
    endif

    check_seasonality(&self)
    scalar self.n_seasonal_components = nelem(getkeys(self.seasonal))

    string self.depvarname = !strlen(argname(y)) ? "Y" : argname(y)
    xlist -= const

    self = self + get_sample_details(y, xlist)
    errorif(self.sample_start_index == self.sample_end_index,\
            "No effective observations available")

    smpl self.sample_start_index self.sample_end_index
    self.T = self.sample_end_index - self.sample_start_index + 1

    self.sample_string = get_sample_string(self.sample_start_index,
                                           self.sample_end_index)

    matrix self.depvar = {scale_series(y, &self)}
    get_xlist_details(xlist, &self)

    self.special_case_id = get_special_case_id(self)

    prepare_system_matrices(&self)

    return self
end function


# TODO: adapt signature
function scalar STSM_estimate (bundle *self,
                               int mapping[0:2:1],
                               int vcvmethod[0:2:1])
    /* Estimates the variances of the model and performs the state smoothing.
    return: Error code, FALSE in case of no error, otherwise TRUE. */
    # mapping: Reparametrisation (0 = Variances, 1 = Std. Dev (def), 2 = log)
    # vcvmethod: 0 = opg, 1 = Hessian (def), 2 = robust

    smpl self.sample_start_index self.sample_end_index
    set warnings off

    if self.special_case_id
        estimate_special_case(&self)
        return FALSE
    endif

    errorif(self.nVar == 0 && self.error_in_obseq == FALSE,\
            "No variances to estimate!")

    scalar has_exog = (self.nexog > 0)
    scalar self.mapping = mapping
    scalar self.vcvmethod = vcvmethod

    matrix self.psi = get_initial_psi_parameters(self)
    scalar self.stdveps = get_initial_stdveps_parameter(self.mapping)

    # TODO: Try to outsource
    if self.verbose < 2
        setopt mle --quiet
    else
        setopt mle --verbose
    endif

    # TODO: Try to outsource
    if self.vcvmethod == 1
        setopt mle --hessian
    elif self.vcvmethod == 2
        setopt mle --robust
    endif

    bundle Model = create_model_object(self)
    matrix Model.inistate = get_initial_state(Model, self)


    if has_exog > 0
        matrix y = mod.depvar
        matrix X = mod.mX
        Model.obsx = X
        matrix beta = mols(diff(y), diff(X)) #.* scale
        psi = psi | beta
    endif

    # ML estimation ---------------------------------------------------------
    # test run
    err = inject(psi, &Model, self.error_in_obseq, nVar, self.Qmat, mapping, nexog)
    err = err || kfilter(&Model)

    errorif( err, "ML init failed!")
        # return 2 # E_DATA
    # else
        if verbose > 1
            printf "Init OK\n"
        endif
        series ll = Model.llt
    # endif

    set lbfgs on # seems to perform better than plain BFGS

    catch mle ll = err ? NA : misszero(ll)
        err = inject(psi, &Model, self.error_in_obseq, nVar, self.Qmat, mapping, nexog)
        err = err || kfilter(&Model)
        series ll = Model.llt
        params psi
    end mle
    scalar err1 = $error

    if err1
        printf "error! %s\n", errmsg(err1)
        return err1
    endif

    # --- mle done; now pack the results nicely ---------------------

    matrices results = adjust($coeff, $vcv, scale, mapping, nexog)
    mod.coeff = results[1]
    mod.vcv = results[2]
    mod.llt = {ll} - ln(scale)

    if self.verbose
        STSM_printout(&self)
    endif

    scalar err = ksmooth(&Model)
    errorif(err, sprintf("Smoothing failed! (%s)", errmsg(err)))
    
    self.St = Model.state * self.y_scaling_factor

    # take care of the unobserved components
    J = Xtract(self.slope, self.seasonal, self.pd)
    k = add_states_to_model(&mod, J)
    J = qformvech(J)
    dg = diag(unvech(seq(1,cols(J))'))
    self.stSE = sqrt(Model.stvar * J[,dg]) * scale

    return 0

end function

###########################################

function scalar STSM_fcast (bundle *mod, int horizon[0], bool verbose[1],
                            bool do_states[0])

    # This function computes forecasts by setting up an auxiliary
    # Kalman bundle in which we append a vector of NAs at the end of the
    # dependent variable and then we run the forward filter; the
    # forecasts are then computed from the filtered states.
    #
    # If (do_states), then store the forecast states too (default: don't)
    # 
    # The case with exogenous variables is a little different because we 
    # need the future values of those. So then we require that the 
    # available sample is larger than the original estimation sample. 

    scalar err = 0
    
    # set forecasting horizon to a sensible default if not passed by the user
    if !exists(horizon) || horizon == 0
        horizon = set_horizon()
    endif

    if mod.special_case
        # handle special cases first
        err = fcast_special_case(&mod, horizon, do_states)
        if verbose
            fcast_printout(mod)
        endif
        return err
    endif

    if mod.nexog > 0
        # Old:
        # printf "Forecasting with exogenous variable not supported yet\n"
        
        errorif( $t2 < mod.fin + horizon, \
          sprintf("need expanded sample (by %d periods ", horizon) ~ \
          "to access exogenous values for forecasting")
          
        if !inbundle(mod, "fullmX") # could already be done by GUI function
            matrix mod.fullmX = {mod.X}
            # cut to desired forecasting horizon if sample is longer
            # (here we kind of hope that the user didn't mess with the 
            # sample start, i.e. only the end can be shifted!)
            mod.fullmX = mod.fullmX[1: mod.T + horizon, ]
        endif
            
        errorif( rows(mod.fullmX) != rows(mod.mX) + horizon, \
            "length of exo values (fullmX) doesn't match horizon")
    endif

    # does mod contain estimates at all?
    errorif( !inbundle(mod, "compnames"), sprintf( \
        "It seems that bundle %s doesn't contain the states\n", argname(mod)))
    #    err = 30 # E_BADSTAT
    #    return err
    # endif

    ###
    # now re-pack stuff into a temporary Kalman bundle
    ###

    # matrices M     = mod.SysMat
    # scalar mapping = mod.mapping
    # scalar scale   = mod.scale
    # scalar self.error_in_obseq = mod.error_in_obseq
    # scalar n       = mod.nVar
    # matrix depvar  = mod.depvar

    # set up the ssm from scratch (Sven: but why actually??)

    matrix F = mod.SysMat[1] # transition matrix
    matrix R = mod.SysMat[2] # map from shocks to state innovations
    matrix H = mod.SysMat[3] # observation matrix
    scalar r = rows(R)
    matrix Sigma = zeros(r, r)
    
    bundle kmod = ksetup(mod.depvar, H, F, Sigma)
    kmod.nexog = mod.nexog
    kmod.scale = mod.scale
    
    if ok(mod.nVar) && mod.nVar > 0 # ok(n) && n > 0
        # matrix coeff = mod.coeff
        err = inject(mod.coeff, &kmod, mod.error_in_obseq, mod.nVar, R, mod.mapping, mod.nexog)
        # (also defines kmod.obsxmat if applicable)
        
        if mod.nexog
            # copy the out-of-sample exo regressors
            matrix kmod.fullmX = mod.fullmX
        endif
    endif

    # perform the forecast and copy the results back to the original bundle

    # bwrite(kmod, "/tmp/before.xml")   # debugging
    err = kfcast(&kmod, do_states, horizon)
    # bwrite(kmod, "/tmp/after.xml")    # debugging

    if !err
        mod = mod + defbundle("fcast", kmod.fcast * mod.scale, "fcastvar", kmod.fcastvar)
        if do_states
            # also store forecasts for the unobserved components
            J = mod.scale * Xtract(mod.slope, mod.seasonal, mod.pd)
            sf = kmod.sfcast * J
            sv = {}
            loop i = 1 .. horizon
                V = unvech(kmod.sfcastvar[i,]')
                sv |= vech(qform(J', V))'
            endloop

            mod = mod + defbundle("sfcast", sf, "sfcastvar", sv)
        endif
    endif

    if verbose
        fcast_printout(mod)
    endif

    return err
end function


function void STSM_printout (bundle *self)
    /* Print results */

    printf "\nStructural model for %s, %s (T = %d)\n",\
        self.depvarname, self.sample_string, self.T

    if self.special_case_id
        print "Estimation carried out via OLS."
    else
        scalar mapping = self.mapping
        strings parameter_labels = get_parameter_labels(self)
        matrix cf = self.coeff ~ sqrt(diag(self.vcv))

        modprint cf parameter_labels

        # TODO: Is this still needed?
        # maps = defarray("Variances", "Std. Dev", "log")
        # printf "mapping = %s, scale = %g\n", maps[mapping+1],\
        #   self.y_scaling_factor

        printf "Average log-likelihood = %g\n", meanc(self.llt)
    endif

    print_specification(self)
end function

#####################################

function list STSM_components (bundle self, bool stderrs[0])
    /* Extract the estimated components. */

    list components = null

    if !inbundle(self, "component_names")
        printf "Warning: It seems that bundle '%s' doesn't contain the states.\n", argname(self)
        return components
    endif

    scalar n_cdesc = nelem(self.stSE)

    loop i=1..nelem(self.component_names)
        string vname = self.component_names[i]
        string desc = self.component_descriptions[i]

        components += genseries(self.component_names[i], self[vname])
        setinfo @vname --description="@desc"

        # don't do irregular & exog
        if stderrs == TRUE && self.special_case_id == FALSE \
            && ( i <= n_cdesc)
            vname += "_se"
            components += genseries(vname, self.stSE[,i])
            setinfo @vname --description="@desc (s.e.)"
        endif
    endloop

    return components
end function

###
### Shortcut functions
###

function list LLT(series y, bool se[0], bundle *out[null])
    mod = STSM_setup(y, 1, 1, 1, 0)
    list ret = null
    if mod.err
        printf "%s\n", errmsg(mod.err)
        return ret
    endif

    mod.depvarname = argname(y)
    mod.err = STSM_estimate(&mod)
    if !mod.err
        list ret = STSM_components(mod, se)
    endif

    if exists(out)
        out = mod
    endif

    return ret
end function

function list BSM(series y, bool se[0], bundle *out[null])
    mod = STSM_setup(y, 1, 1, 1, 2)
    list ret = null
    if mod.err
        printf "%s\n", errmsg(mod.err)
        return ret
    endif

    mod.depvarname = argname(y)
    mod.err = STSM_estimate(&mod)
    if !mod.err
        list ret = STSM_components(mod, se)
    endif

    if exists(out)
        out = mod
    endif

    return ret
end function
