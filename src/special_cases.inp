function scalar get_special_case_id (const bundle self)
    /* Check for a few special cases that need no numerical optimisation */

    scalar ret = 0
    stochastic_trend = (self.type_trend == "stochastic")
    stochastic_slope = (self.type_slope == "stochastic")
    stochastic_season = stochastic_season_exists(self)

    # TODO: I think the if-conditions may be simplified
    if !(stochastic_trend || stochastic_slope || stochastic_trend)
    	if stochastic_trend == FALSE && \
            self.type_slope == "none" && self.n_seasonal_components == 0
    	    # case 1: just a constant + irregular
    	    ret = 1

    	elif stochastic_trend == FALSE && \
            self.type_slope == "deterministic" && self.n_seasonal_components == 0
    	    # case 2: constant + trend + irregular
    	    ret = 2

        elif stochastic_trend == FALSE && \
            self.type_slope == "none" && stochastic_season == FALSE
    	    # case 3: constant + seasonal dummies + irregular
    	    ret = 3

        elif stochastic_trend == FALSE && \
            self.type_slope == "deterministic" && stochastic_season == FALSE
    	    # case 4: constant + trend + seasonal dummies + irregular
    	    ret = 4
    	endif
    endif

    return ret
end function


function matrix special_case_seasonals (const bundle self, const matrix trend)
    /* Construct seasonals for estimating special cases.
    return: type, description */

    matrix X
    strings components = getkeys(self.seasonal)

    loop foreach i components
        frq = self.seasonal["$i"].frequency

        matrix seas = (trend % frq) .= seq(1, (frq-1))
        X ~= seas - (1 / frq)
    endloop

    return X
end function

function matrix special_case_state (const bundle self,
                                    const matrix X,
                                    const matrix coeff)
    /* Compute state for special cases.
    return: matrix, Holds the estimated (un-scaled) components such as level etc.  */

    matrix state

    if self.special_case_id == 1
       state = X * coeff
    elif self.special_case_id == 2
        state = X[,1:2] * coeff[1:2]
        state = state ~ mshape(coeff[2], self.T, 1)
    elif self.special_case_id == 3
       state = mshape(coeff[1], self.T, 1) ~ X[,2:] * coeff[2:]
    elif self.special_case_id == 4
        state = X[,1:2] * coeff[1:2]
        state = state ~ mshape(coeff[2], self.T, 1)
        state = state ~ X[,3:] * coeff[3:]
    endif

    return state
end function

function void special_case_seasonal_component (bundle *self,
                                               const matrix states)
    /* Retrieve seasonal component as series, add variable names to bundle. */

    strings components = getkeys(self.seasonal)

    loop foreach i components
       scalar frq = ceil(self.seasonal["$i"].frequency)
       string vname = sprintf("%s_seas_%d", self.depvarname, frq)
       genseries(vname, states[,i])
       self.component_names += vname
       self.component_descriptions += sprintf("Seasonal Freq = %g (deterministic)",\
                                 self.seasonal["$i"].frequency)
       self[vname] = @vname
    endloop
end function

function matrix handle_special_case (const bundle self)
    /* */

    matrix X = ones(self.T, 1)
    matrix trend = seq(1, self.T)'
    matrix uhat = {}

    if (self.special_case_id == 2) || (self.special_case_id == 4)
	   X ~= trend
    endif
    if (self.special_case_id == 3) || (self.special_case_id == 4)
        X ~= special_case_seasonals(self, trend)
    endif

    coeff = mols(self.depvar, X, &uhat)
    matrix state = special_case_state(self, X, coeff)

    return uhat ~ state
end function

function scalar add_states_special (matrix states, bundle *self)
    /* */

    strings self.component_names = null
    strings self.component_descriptions = null
    scalar counter = 2
    scalar self.nStates = cols(states) - 1

    # irregular component
    string vname = self.depvarname ~ "_irreg"
    genseries(vname, states[,1])
    self.component_names += vname
    self.component_descriptions += "Irregular"
    self[vname] = @vname  # store series

    # level component
    string vname = self.depvarname ~ "_level"
    genseries(vname, states[,2])
    self.component_names += vname
    self.component_descriptions += "Trend level"
    self[vname] = @vname

    # slope component if present
    if (self.special_case_id == 2) || (self.special_case_id  == 4)
	   counter++
       vname = self.depvarname ~ "_slope"
       genseries(vname, states[,counter])
       self.component_names += vname
       self.component_descriptions += "Slope"
	   self[vname] = @vname
    endif
 
    # seasonal component(s), if present
    if (self.special_case_id == 3) || (self.special_case_id  == 4)
       counter += self.n_seasonal_components
       scalar ini = counter
       scalar ende = ini + self.n_seasonal_components - 1
	   special_case_seasonal_component(&self, states[, ini:ende])
    endif

    # exogenous component, if present
    if 0 # not for now
	   counter++
	   nVar = self.nVar
       vname = name ~ "_exo"
	
	   beta = self.coeff[has_eps + self.nVar + 1:]
       genseries(vname, self.mX * beta)
       self.component_names += vname
	   self.component_descriptions += "Exogenous"
        model[vname] = @vname
        if has_eps
            series eps -= @vname
        endif
    endif
    
    self.stSE = mshape(NA, self.T, counter)

    return counter
end function


function void estimate_special_case (bundle *self)
    /* Call functions for estimating special case specifications which do not require numerical optimisation. */

    matrix components = handle_special_case(self) # unscaled components
    matrix components *= self.y_scaling_factor

    add_states_special(components, &self)

    if self.verbose
        STSM_printout(&self)
    endif
    stop
end function
