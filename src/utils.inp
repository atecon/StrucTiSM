function bundle default_model_bundle (void)
    /* Compile the default bundle holding model parameters */

    bundle self = null

    scalar self.err = FALSE
    scalar self.verbose = TRUE
    scalar self.error_in_obseq = TRUE          # formerly "epsilon"
    string self.type_trend = "deterministic"   # {"stochastic" "deterministic"}
    string self.type_slope = "none"  # {"none" "stochastic" "deterministic"}
    scalar self.pd = $pd

    bundle self.seasonal_info = null
    #bundle self.seasonal_info.component_1 = null
    #scalar self.seasonal_info.component_1.stochastic = FALSE
    #string self.seasonal_info.component_1.type = "dummy"    # {"dummy", "trigonometric"}
    # scalar self.seasonal_info.component_1.frequency = $pd

    scalar self.nStates = NA
    scalar self.nVar = NA       # number of variances to estimate
    scalar self.y_scaling_factor = NA

    return self
end function


function void check_seasonality (bundle *self)
    /* Check if dataset has seasonality. If not, reset seasonal bundle. */

    if $pd == 1
        print "The dataset has no seasonality. Eventuall specified seasonality will be ignored."
        bundle self.seasonal_info = null
    endif
end function


function bundle get_sample_details (const series y, const list xlist[null])
    /* Get sample start and end.
    return: bundle, holding index of start and end date */

    bundle self

    list Z = y xlist
    series okobs = zeromiss(ok(Z))
    scalar self.sample_start_index = xmax(firstobs(okobs), $t1)
    scalar self.sample_end_index = xmin(lastobs(okobs), $t2)


    return self
end function

function string get_sample_string (const int start_index,
                                   const int end_index)
    return sprintf("%s - %s", obslabel(start_index), obslabel(end_index))
end function


function scalar stochastic_season_exists (const bundle self)
    /* code description
    return: type, description */

    scalar ret = 0
    strings components = getkeys(self.seasonal_info)

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        if self.seasonal_info["@key"].stochastic == TRUE
            ret++
        endif
    endloop

    return (ret > 0) ? TRUE : FALSE
end function


function void get_xlist_details (list xlist, bundle *self)
    /* Add some details about xlist to bundle. */

    scalar self.nexog = nelem(xlist)

    if self.nexog
        list self.xlist = xlist
        string self.xnames = varname(xlist)
        matrix self.mX = {xlist}
    endif
end function


function scalar set_horizon(void)
    # some sensible defaults
    
    if $pd == 1
        horizon = 10
    elif ($pd == 4)
        horizon = 8
    elif ($pd == 5) || ($pd == 6) || ($pd == 7)
        horizon = 2 * $pd
    elif ($pd == 12)
        horizon = 12
    else
        horizon = $pd
    endif
    return horizon
end function


function matrix get_initial_psi_parameters (const bundle self)
    /* Initialize parameters to estimate. */

    if self.mapping == 2    # logarithmic case
        return zeros(self.nVar + self.error_in_obseq, 1)
    endif
    # TODO: WHY multiply by '4'?
    scalar a = get_initial_stdveps_parameter(self.mapping)
    return ones(self.nVar + self.error_in_obseq, 1) .* a
end function


function scalar get_initial_stdveps_parameter (const scalar mapping)
    /* Initialize parameters to estimate. */

    if mapping == 2    # logarithmic case
        return 0
    else
        return 4
    endif
end function

###
### Variance estimation: from (-infty, infty) to (0, infty) and vice versa
###

function matrix reparm (const matrix psi,
                        int mapping[0:2:1],
                        bool inverse[0])
    /* This function returns _variances_ for given parameters.
    Options are: 0 = abs, 1 = square, 2 = exp */

    set warnings off
    matrix ret

    if mapping == 1
        # what goes into mle is std. devs
        ret = inverse ? sqrt(psi) : psi.^2
    elif mapping == 2
        # what goes into mle is log variances
        ret = inverse ? ln(psi) : exp(psi)
    else
        # what goes into mle is variances
        ret = abs(psi)
    endif

    return ret
end function


function scalar inject (const bundle self,
                        bundle *model)
    /* This function injects the mle parameters into the Kalman bundle,
    given the characteristics of the model. */

    scalar err = FALSE   # TODO: Just a dummy needed for mle block?
    scalar init = self.error_in_obseq == TRUE ? 2 : 1

    if self.error_in_obseq
        # [1]: irregular component is always positioned first
        model.obsvar = reparm(self.psi[1], self.mapping)
    endif

    model.statevar[diag] = self.Qmat * reparm(self.psi[init:], self.mapping)

    if self.nexog > 0
        model.obsxmat = self.psi_exogenous
    endif

    return err
end function

function series scale_series (const series y,
                              bundle *self)
    # TODO: For now

    self.y_scaling_factor = sd(y) / 100
    series ret = y / self.y_scaling_factor

    if self.verbose
        printf "Info: Scale for dependent variable = %g\n",\
            self.y_scaling_factor
    endif

    return ret
end function


function bundle remap_coefficients (const matrix coeff,
                                    const matrix vcv,
                                    const bundle self)
    /* Tis function re-maps the parameters used in "mle" into standard
    deviations, in the orginal unit of measurement.
    ret[1] contains the parameters, ret[2] their vcv
    (computed via the delta method). */

    bundle B

    scalar k = rows(coeff) - self.nexog
    matrix vc = coeff[1:k]
    matrix se_unscaled = sqrt(reparm(vc, self.mapping))
    matrix se_scaled = se_unscaled * self.y_scaling_factor

    # the Jacobian
    if self.mapping == 0
        matrix J = 0.5 * self.y_scaling_factor ./ se_unscaled
    elif self.mapping == 1
        matrix J = mshape(self.y_scaling_factor, k, 1)
    elif self.mapping == 2
        matrix J = 0.5 .* se_scaled
    endif

    matrix vcv_scaled = vcv[1:k,1:k] .* (J*J')

    if self.nexog
        self.sample_start_index = k + 1
        fini = k+nexog

        se_scaled |= coeff[self.sample_start_index:fini] * self.y_scaling_factor
        vcv_scaled = diagcat(vcv_scaled,\
                             self.y_scaling_factor^2 * vcv[self.sample_start_index:fini,self.sample_start_index:fini])
    endif

    return _(coeff = se_scaled, vcv = vcv_scaled)
end function


function strings get_seasonal_parameter_labels (const bundle self)
    /* Construct parameter labels for seasonal components. */

    strings components = getkeys(self.seasonal_info)
    strings ret = array(nelem(components))

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        ret[i] = sprintf("Seasonal (%s, F=%.2f)",\
                         self.seasonal_info["@key"].type,\
                         self.seasonal_info["@key"].frequency)
    endloop

    return ret
end function


function strings get_parameter_labels (const bundle self)
    /* Create array of parameter labels. */

    strings ret = array(0)

    if self.error_in_obseq
        ret += "Irregular"
    endif

    ret += sprintf("Trend (%s)", self.type_trend)

    if self.type_slope != "none"
        ret += sprintf("Slope (%s)", self.type_slope)
    endif

    ret += get_seasonal_parameter_labels(self)

    if self.nexog > 0
        ret += self.xnames
    endif

    return ret
end function

function void print_specification_seasonal (const bundle self)
    /* Print specification for seasonals. */

    strings components = getkeys(self.seasonal_info)

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        string s = self.seasonal_info["@key"].stochastic == TRUE ? \
                   "stochastic" : "deterministic"

        printf ", seasonal"
        if nelem(components) > 1
            printf " (%d)", i
        endif
        printf ": %s (%s, F=%.2f)",\
            s, self.seasonal_info["@key"].type, self.seasonal_info["@key"].frequency
    endloop
end function


function void print_specification (const bundle self)
    /* Print specification. */

    printf "\n\nSpecification:\n"
    printf "================\n"

    printf "Trend: %s", self.type_trend
    printf ", slope: %s", self.type_slope

    print_specification_seasonal(self)

    if self.error_in_obseq
            printf "\n, irregular component"
    endif
    printf "\n\n"
end function


function matrix Xtract (const bundle self)
    /* This function creates an n x k matrix, which extracts the components
    to export from the state vector the level is always there, either
    deterministic or stochastic. */

    matrix ret = {1}

    if self.type_slope != "none"
        ret = diagcat(ret, 1)
    endif

    strings components = getkeys(self.seasonal_info)

    if nelem(components) > 1
        print "ERROR: TODO: Currently this only supports a single seasonal component"
        print "We need to stack further seasonal components here"
        stop
    endif

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)
        scalar pd_factor = self.seasonal_info["@key"].frequency

        if self.seasonal_info["@key"].stochastic == TRUE && \
           self.seasonal_info["@key"].type == "trigonometric"

            ret = diagcat(ret, mshape({1,0}, (pd_factor - 1), 1))

        elif self.seasonal_info["@key"].type == "dummy"
            ret = diagcat(ret, 1 | zeros((pd_factor - 2), 1))
        endif
    endloop

    return ret
end function


# TODO: This function does way too many things at the moment
function scalar add_states_to_model (bundle *self, const matrix J)
    /* Return the number of components. */

    if !inbundle(self, "state")
        printf "Error: States not found on model bundle.\n"
        return 0
    endif

    strings component_names = null
    strings component_descriptions = null
    scalar k = 1

    smpl self.sample_start_index self.sample_end_index

    # initialise the "residuals"
    if self.error_in_obseq
        series eps = self.depvar * self.y_scaling_factor
    endif

    # "name" holds the outer name of the dependent variable
    string name = self.depvarname
    scalar nStates = self.nStates
    matrix stateJ = self.state * J

    # do the level ---------------------------------------------
    string sername = name ~ "_level"
    genseries(sername, stateJ[,1])
    component_names += sername
    component_descriptions += "Trend level"
    self[sername] = @sername

    if self.error_in_obseq
        series eps -= @sername
    endif

    # do the slope, if present ---------------------------------
    if self.type_slope == "stochastic"
        k++
        sername = name ~ "_slope"
        genseries(sername, stateJ[,k])
        component_names += sername
        component_descriptions += "Slope"
        self[sername] = @sername
    elif self.type_slope == "deterministic"
        # just skip the deterministic slope
        k++
    endif

    # do the seasonal(s), if present ------------------------------
    if nelem(self.seasonal_info) > 0
        strings components = getkeys(self.seasonal_info)

        loop i=1..nelem(components)
            k++
            string key = sprintf("component_%d", i)

            string sername = sprintf("%s_seas%d",
                                     name,
                                     self.seasonal_info["@key"].frequency)

            genseries(sername, stateJ[,k])
            component_names += sername
            string desc = self.seasonal_info["@key"].stochastic ? \
                          ", stochastic" : ""
            component_descriptions += sprintf("Seasonal (%s%s)",
                                 self.seasonal_info["@key"].type,
                                 desc)
            self[sername] = @sername
            if self.error_in_obseq
                series eps -= @sername
            endif
        endloop
    endif

    # do the exogenous component, if present ---------------------
    if self.nexog >= 1
        k++
        nVar = self.nVar
        sername = name ~ "_exo"

        beta = self.coeff[self.error_in_obseq + self.nVar + 1:]
        genseries(sername, self.mX * beta)
        component_names += sername
        component_descriptions += "Exogenous"
        self[sername] = @sername
        if self.error_in_obseq
            series eps -= @sername
        endif
    endif

    # finalise the irregular component, if present --------------
    if self.error_in_obseq
        k++
        sername = name ~ "_irreg"
        genseries(sername, eps)
        component_names += sername
        component_descriptions += "Irregular"
        self[sername] = @sername
    endif

    # Add the names of the newly created series to the bundle
    strings self.component_names = component_names
    strings self.component_descriptions = component_descriptions

    return k
end function


function matrix ols_exogenous (const bundle self)
    /* Estimate effect of exogenous on endogenous.
    return: matrix, vector of point estimates. */

    matrix y = diff(self.depvar)
    matrix X = diff(self.mX)
    matrix coeff = mols(y, X)   # TODO: Is scaling needed? ".* scale"

    return coeff
end function
