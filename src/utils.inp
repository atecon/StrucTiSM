function bundle default_model_bundle (void)
    /* Compile the default bundle holding model parameters */

    bundle self = null

    scalar self.err = FALSE
    scalar self.verbose = TRUE
    scalar self.error_in_obseq = TRUE          # formerly "epsilon"
    string self.type_trend = "deterministic"   # {"stochastic" "deterministic"}
    string self.type_slope = "none"  # {"none" "stochastic" "deterministic"}
    scalar self.pd = $pd

    bundle self.seasonal_info = null
    #bundle self.seasonal_info.component_1 = null
    #scalar self.seasonal_info.component_1.stochastic = FALSE
    #string self.seasonal_info.component_1.type = "dummy"    # {"dummy", "trigonometric"}
    # scalar self.seasonal_info.component_1.frequency = $pd

    scalar self.nStates = NA
    scalar self.nVar = NA       # number of variances to estimate
    scalar self.y_scaling_factor = NA

    return self
end function


function void check_seasonality (bundle *self)
    /* Check if dataset has seasonality. If not, reset seasonal bundle. */

    if $pd == 1
        print "The dataset has no seasonality. Eventuall specified seasonality will be ignored."
        bundle self.seasonal_info = null
    endif
end function


function bundle get_sample_details (const series y, const list xlist[null])
    /* Get sample start and end.
    return: bundle, holding index of start and end date */

    bundle self

    list Z = y xlist
    series okobs = zeromiss(ok(Z))
    scalar self.sample_start_index = xmax(firstobs(okobs), $t1)
    scalar self.sample_end_index = xmin(lastobs(okobs), $t2)


    return self
end function

function string get_sample_string (const int start_index,
                                   const int end_index)
    return sprintf("%s - %s", obslabel(start_index), obslabel(end_index))
end function


function scalar stochastic_season_exists (const bundle self)
    /* code description
    return: type, description */

    scalar ret = 0
    strings components = getkeys(self.seasonal_info)

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        if self.seasonal_info["@key"].stochastic == TRUE
            ret++
        endif
    endloop

    return (ret > 0) ? TRUE : FALSE
end function


function void get_xlist_details (list xlist, bundle *self)
    /* Add some details about xlist to bundle. */

    scalar self.nexog = nelem(xlist)

    if self.nexog
        list self.xlist = xlist
        string self.xnames = varname(xlist)
        matrix self.mX = {xlist}
    endif
end function


function scalar set_horizon(void)
    # some sensible defaults
    
    if $pd == 1
        horizon = 10
    elif ($pd == 4)
        horizon = 8
    elif ($pd == 5) || ($pd == 6) || ($pd == 7)
        horizon = 2 * $pd
    elif ($pd == 12)
        horizon = 12
    else
        horizon = $pd
    endif
    return horizon
end function


function matrix get_initial_psi_parameters (const bundle self)
    /* Initialize parameters to estimate. */

    if self.mapping == 2    # logarithmic case
        return zeros(self.nVar + self.error_in_obseq, 1)
    endif
    # TODO: WHY multiply by '4'?
    scalar a = get_initial_stdveps_parameter(self.mapping)
    return ones(self.nVar + self.error_in_obseq, 1) .* a
end function


function scalar get_initial_stdveps_parameter (const scalar mapping)
    /* Initialize parameters to estimate. */

    if mapping == 2    # logarithmic case
        return 0
    else
        return 4
    endif
end function

###
### Variance estimation: from (-infty, infty) to (0, infty) and vice versa
###

function matrix reparm (const matrix psi,
                        int mapping[0:2:1],
                        bool inverse[0])
    /* This function returns _variances_ for given parameters.
    Options are: 0 = abs, 1 = square, 2 = exp */

    set warnings off
    matrix ret

    if mapping == 1
        # what goes into mle is std. devs
        ret = inverse ? sqrt(psi) : psi.^2
    elif mapping == 2
        # what goes into mle is log variances
        ret = inverse ? ln(psi) : exp(psi)
    else
        # what goes into mle is variances
        ret = abs(psi)
    endif

    return ret
end function


function scalar inject (const bundle self,
                        bundle *model)
    /* This function injects the mle parameters into the Kalman bundle,
    given the characteristics of the model. */

    scalar err = FALSE   # TODO: Just a dummy needed for mle block?
    scalar init = self.error_in_obseq == TRUE ? 2 : 1

    if self.error_in_obseq
        # [1]: irregular component is always positioned first
        model.obsvar = reparm(self.psi[1], self.mapping)
    endif

    model.statevar[diag] = self.Qmat * reparm(self.psi[init:], self.mapping)

    if self.nexog > 0
        model.obsxmat = self.psi_exogenous
    endif

    return err
end function

function series scale_series (const series y,
                              bundle *self)
    # TODO: For now

    self.y_scaling_factor = sd(y) / 100
    series ret = y / self.y_scaling_factor

    if self.verbose
        printf "Info: Scale for dependent variable = %g\n",\
            self.y_scaling_factor
    endif

    return ret
end function



function bundle remap_coefficients (const matrix coeff,
                                    const matrix vcv,
                                    const bundle self)
    /* Tis function re-maps the parameters used in "mle" into standard
    deviations, in the orginal unit of measurement.
    ret[1] contains the parameters, ret[2] their vcv
    (computed via the delta method). */

    bundle B

    scalar k = rows(coeff) - self.nexog
    matrix vc = coeff[1:k]
    matrix se_unscaled = sqrt(reparm(vc, self.mapping))
    matrix se_scaled = se_unscaled * self.y_scaling_factor

    # the Jacobian
    if self.mapping == 0
        matrix J = 0.5 * self.y_scaling_factor ./ se_unscaled
    elif self.mapping == 1
        matrix J = mshape(self.y_scaling_factor, k, 1)
    elif self.mapping == 2
        matrix J = 0.5 .* se_scaled
    endif

    matrix vcv_scaled = vcv[1:k,1:k] .* (J*J')

    if self.nexog
        ini = k + 1
        fini = k+nexog

        se_scaled |= coeff[ini:fini] * self.y_scaling_factor
        vcv_scaled = diagcat(vcv_scaled,\
                             self.y_scaling_factor^2 * vcv[ini:fini,ini:fini])
    endif

    return _(coeff = se_scaled, vcv = vcv_scaled)
end function


function strings get_seasonal_parameter_labels (const bundle self)
    /* Construct parameter labels for seasonal components. */

    strings components = getkeys(self.seasonal_info)
    strings ret = array(nelem(components))

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        ret[i] = sprintf("Seasonal (%s, F=%.2f)",\
                         self.seasonal_info["@key"].type,\
                         self.seasonal_info["@key"].frequency)
    endloop

    return ret
end function


function strings get_parameter_labels (const bundle self)
    /* Create array of parameter labels. */

    strings ret = array(0)

    if self.error_in_obseq
        ret += "Irregular"
    endif

    ret += sprintf("Trend (%s)", self.type_trend)

    if self.type_slope != "none"
        ret += sprintf("Slope (%s)", self.type_slope)
    endif

    ret += get_seasonal_parameter_labels(self)

    if self.nexog > 0
        ret += self.xnames
    endif

    return ret
end function

function void print_specification_seasonal (const bundle self)
    /* Print specification for seasonals. */

    strings components = getkeys(self.seasonal_info)

    loop i=1..nelem(components)
        string key = sprintf("component_%d", i)

        string s = self.seasonal_info["@key"].stochastic == TRUE ? \
                   "stochastic" : "deterministic"

        printf ", seasonal"
        if nelem(components) > 1
            printf " (%d)", i
        endif
        printf ": %s (%s, F=%.2f)",\
            s, self.seasonal_info["@key"].type, self.seasonal_info["@key"].frequency
    endloop
end function


function void print_specification (const bundle self)
    /* Print specification. */

    printf "\n\nSpecification:\n"
    printf "================\n"

    printf "Trend: %s", self.type_trend
    printf ", slope: %s", self.type_slope

    print_specification_seasonal(self)

    if self.error_in_obseq
            printf "\n, irregular component"
    endif
    printf "\n\n"
end function


function matrix Xtract (int slope, int seasonal, scalar pd)
    /* This function creates an n x k matrix, which extracts the components
    to export from the state vector the level is always there, either
    deterministic or stochastic. */

    matrix ret = {1}

    if slope > 0
        ret = diagcat(ret, 1)
    endif

    if seasonal == 1
        ret = diagcat(ret, mshape({1,0}, pd-1, 1))
    elif seasonal == 2 || seasonal == 3
        ret = diagcat(ret, 1 | zeros(pd-2, 1))
    endif

    return ret
end function

function scalar add_states_to_model(bundle *model, const matrix J)

    # does model contain estimates at all?
    if !inbundle(model, "St")
        printf "Error!\n"
        return 0
    endif

    strings compnames = null
    strings compdescs = null
    scalar k = 1
    scalar has_eps = model.epsilon
    scalar ini = model.ini
    scalar fin = model.fin
    smpl ini fin

    # initialise the "residuals"
    if has_eps
        series eps = model.depvar * model.scale
    endif

    # "name" holds the outer name of the dependent variable
    name = model.depvarname
    nStates = model.nStates
    pd = model.pd
    matrix St = model.St * J

    # do the level ---------------------------------------------
    string sername = name ~ "_level"
    genseries(sername, St[,1])
    compnames += sername
    compdescs += "Trend level"
    model[sername] = @sername

    if has_eps
        series eps -= @sername
    endif

    # do the slope, if present ---------------------------------
    if model.slope == 1
        k++
        sername = name ~ "_slope"
        genseries(sername, St[,k])
        compnames += sername
        compdescs += "Slope"
        model[sername] = @sername
    elif model.slope == 2
        # just skip the deterministic slope
        k++
    endif

    # do the seasonal, if present ------------------------------
    if model.seasonal >= 1
        k++
        # printf "(seasonal) k = %d\n", k
        sername = name ~ "_seas"
        genseries(sername, St[,k])
        compnames += sername
        if model.seasonal == 1
            compdescs += "Seasonal (with trigon. terms)"
        elif model.seasonal > 1
            compdescs += "Seasonal (with dummies)"
        endif
        model[sername] = @sername
        if has_eps
            series eps -= @sername
        endif
    endif

    # do the exogenous component, if present ---------------------
    if model.nexog >= 1
        k++
        nVar = model.nVar
        sername = name ~ "_exo"

        beta = model.coeff[has_eps + model.nVar + 1:]
        genseries(sername, model.mX * beta)
        compnames += sername
        compdescs += "Exogenous"
        model[sername] = @sername
        if has_eps
            series eps -= @sername
        endif
    endif

    # finalise the irregular component, if present --------------
    if has_eps
        k++
        sername = name ~ "_irreg"
        genseries(sername, eps)
        compnames += sername
        compdescs += "Irregular"
        model[sername] = @sername
    endif

    # Add the names of the newly created series to the bundle
    strings model.compnames = compnames
    strings model.compdescs = compdescs

    return k
end function


function matrix ols_exogenous (const bundle self)
    /* Estimate effect of exogenous on endogenous.
    return: matrix, vector of point estimates. */

    matrix y = diff(self.depvar)
    matrix X = diff(self.mX)
    matrix coeff = mols(y, X)   # TODO: Is scaling needed? ".* scale"

    return coeff
end function
